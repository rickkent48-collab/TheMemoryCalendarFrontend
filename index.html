<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>memories calendar 2025</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#fff1b8" />
  <link rel="manifest" href="manifest.webmanifest" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;600;700&family=Poppins:wght@400;600;700&family=Merriweather:wght@400;700&family=Cookie&family=Dancing+Script&family=Pacifico&family=Boogaloo&family=Caveat&family=Indie+Flower&family=Jersey+10&display=swap" rel="stylesheet">
  <style>
    :root{
      --text:#3a1a5e;
      --bg1:#fff1b8;
      --bg2:#ffd3b6;
      --bg3:#ffb3c1;
      --pad:14px;
      --gap:6px;
      --day-radius:10px;
      --shadow:0 2px 6px rgba(0,0,0,0.08);
      --topbar-h:64px;
      --content-max:520px;
      --title-size:18px;
      --note-fs:14px;
      --note-lh:1.35;
      --note-lines:3;
      --emoji-size:34px;
      --emoji-gap:10px;
      --word-height:42px;
      --outline-color:#7e57c2;
      --polaroid-border:6px;
      --polaroid-radius:14px;
      --inner-radius:12px;
      --icon-size:18px;
      --icon-stroke:1.8;
      --app-font:"Comfortaa",sans-serif;
      --surface:#ffffff;
      --button-bg:#ffffff;
      --button-text:var(--text);
    }
    :root[data-theme="pastel"]{ --text:#3a1a5e; --bg1:#fff1b8; --bg2:#ffd3b6; --bg3:#ffb3c1; --surface:#ffffff; --button-bg:#ffffff; --button-text:#3a1a5e; --outline-color:#7e57c2; }
    :root[data-theme="dark"]{ --text:#f4f4f7; --bg1:#000000; --bg2:#000000; --bg3:#000000; --surface:#2c2c3a; --button-bg:#2c2c3a; --button-text:#f4f4f7; --outline-color:#b388ff; }
    :root[data-theme="light"]{ --text:#222222; --bg1:#FFFFFF; --bg2:#FFFFFF; --bg3:#FFFFFF; --surface:#ffffff; --button-bg:#ffffff; --button-text:#222222; --outline-color:#7e57c2; }
    :root[data-theme="galaxy"]{ --text:#e6e9ff; --bg1:#2b1055; --bg2:#4b2d83; --bg3:#1b3987; --surface:#3a2570; --button-bg:#3a2570; --button-text:#e6e9ff; --outline-color:#8f7fff; }
    :root[data-theme="sunset"]{ --text:#2d132c; --bg1:#ffaf87; --bg2:#ff8e6e; --bg3:#ff6f91; --surface:#fff2e6; --button-bg:#fff2e6; --button-text:#2d132c; --outline-color:#ff6f91; }
    :root[data-theme="forest"]{ --text:#1f3324; --bg1:#c9f2d6; --bg2:#8fd7a3; --bg3:#4e9f6b; --surface:#ffffff; --button-bg:#ffffff; --button-text:#1f3324; --outline-color:#31734b; }
    :root[data-theme="underwater"]{ --text:#e7fbff; --bg1:#023e8a; --bg2:#0077b6; --bg3:#0096c7; --surface:#00b4d8; --button-bg:#00b4d8; --button-text:#e7fbff; --outline-color:#90e0ef; }
    :root[data-theme="underwater"] .polaroid-placeholder{ color:#062a56; opacity:.9; }
    :root[data-theme="rainbow"]{ --text:#2e2e2e; --bg1:#ff9a9e; --bg2:#fad0c4; --bg3:#ffd1ff; --surface:#ffffff; --button-bg:#ffffff; --button-text:#2e2e2e; --outline-color:#ff6ec7; }
    :root[data-theme="fire"]{ --text:#1A1A1A; --bg1:#F36B6B; --bg2:#F7A860; --bg3:#F9E27D; --surface:#ffffff; --button-bg:#ffffff; --button-text:#1A1A1A; --outline-color:#E85D5D; }
    :root[data-theme="earth"]{ --text:#FFFFFF; --bg1:#2E8B57; --bg2:#3fa87a; --bg3:#1E90FF; --surface:#2d5f4a; --button-bg:#2d5f4a; --button-text:#FFFFFF; --outline-color:#4FC3F7; }
    :root[data-theme="sunset"] .agree-box{ border-color:#ff9fb3; }

    @supports (height:1svh){ :root{ --sheet-h:75svh; } }
    @supports (height:1dvh){ :root{ --sheet-h:75dvh; } }

    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; }
    html,body,*{ -ms-overflow-style:none; scrollbar-width:none; }
    ::-webkit-scrollbar{ width:0; height:0; display:none; }

    body{
      color:var(--text);
      font-family:var(--app-font);
      background:linear-gradient(180deg,var(--bg1) 0px,var(--bg1) calc(var(--topbar-h) + 1px),var(--bg2) 55%,var(--bg3) 100%);
      background-attachment:fixed;
      -webkit-tap-highlight-color:transparent;
      overflow-x:hidden;
      text-transform:lowercase;
    }

    .fs-screen,
    #dayModal,
    #frameModal,
    #yearModal{
      background-attachment:fixed;
      background-repeat:no-repeat;
      background-size:100% 100%;
    }

    :root[data-caps="none"] body{ text-transform:lowercase; }
    :root[data-caps="all"] body{ text-transform:uppercase; }
    :root[data-caps="standard"] body{ text-transform:none; }

    :root[data-caps="standard"] .topbar .title,
    :root[data-caps="standard"] header,
    :root[data-caps="standard"] .section-header,
    :root[data-caps="standard"] .emoji-chip,
    :root[data-caps="standard"] .word-chip,
    :root[data-caps="standard"] .custom-word-chip input,
    :root[data-caps="standard"] button:not(.fixed-case-none):not(.fixed-case-standard):not(.fixed-case-all){
      text-transform:capitalize;
    }

    :root[data-caps="all"] button:not(.fixed-case-none):not(.fixed-case-standard):not(.fixed-case-all){
      text-transform:uppercase !important;
    }

    .choice-btn.fixed-case-none{ text-transform:lowercase !important; }
    .choice-btn.fixed-case-standard{ text-transform:none !important; }
    .choice-btn.fixed-case-all{ text-transform:uppercase !important; }

    input,textarea,button{ font-family:var(--app-font); color:var(--text); }

    body.lock-scroll{ position:fixed; overflow:hidden; width:100%; height:100%; }
    body.sheet-open .app{ pointer-events:none; touch-action:none; }

    .topbar{
      position:fixed; top:0; left:0; right:0;
      z-index:2000;
      display:flex; align-items:center; justify-content:space-between;
      gap:8px;
      padding:calc(env(safe-area-inset-top,0px) + 10px) var(--pad) 10px;
      background:linear-gradient(180deg,var(--bg1) 0%,var(--bg1) 100%);
      box-sizing:border-box;
    }
    .topbar .title{
      font-size:var(--title-size);
      font-weight:800;
      letter-spacing:1.5px;
      line-height:1;
      cursor:pointer;
      flex:1;
      text-align:center;
      user-select:none;
      display:flex; align-items:center; justify-content:center;
      height:var(--icon-size);
    }
    .icon-btn{
      flex:0 0 auto;
      width:44px; height:44px;
      display:grid; place-items:center;
      background:transparent; border:none;
      cursor:pointer; padding:0;
      color:var(--text);
    }
    .icon-btn svg{
      width:var(--icon-size);
      height:var(--icon-size);
      stroke:currentColor;
      fill:none;
      stroke-width:var(--icon-stroke);
      stroke-linecap:round;
      stroke-linejoin:round;
      vector-effect:non-scaling-stroke;
      display:block;
    }

    .app{
      padding:calc(var(--topbar-h) + 6px) 0 calc(var(--pad) + env(safe-area-inset-bottom,0px));
      max-width:920px; margin:0 auto; overflow:hidden;
    }

    .cal-carousel{
      display:flex; overflow-x:auto;
      scroll-snap-type:x mandatory;
      -webkit-overflow-scrolling:touch;
      touch-action:pan-x pan-y;
      scroll-behavior:smooth;
    }
    .cal-page{
      flex:0 0 100%; width:100%;
      padding:0 var(--pad);
      scroll-snap-align:start;
      scroll-snap-stop:always;
      position:relative;
    }
    .month h2{
      margin:0;
      font-size:var(--title-size);
      font-weight:800;
      text-align:center;
      letter-spacing:1.5px;
      line-height:1.1;
    }
    .grid{
      display:grid;
      grid-template-columns:repeat(7,1fr);
      gap:var(--gap);
      margin:16px 0;
    }
    .day{
      position:relative;
      aspect-ratio:1/1;
      background:var(--surface);
      border-radius:10px;
      overflow:hidden;
      box-shadow:var(--shadow);
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:14px;
      font-weight:700;
      color:var(--text);
    }
    .day .num{ pointer-events:none; line-height:1; }
    .day.has-photo .num,
    .day.has-emoji .num{ display:none; }
    .day img{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit:cover;
      display:none;
    }
    .emoji-badge{
      font-size:22px;
      line-height:1;
      pointer-events:none;
    }
    .pad{ aspect-ratio:1/1; opacity:0; }

    .toast{
      position:fixed; left:50%;
      bottom:calc(16px + env(safe-area-inset-bottom,0px));
      transform:translateX(-50%);
      background:var(--surface);
      color:var(--text); padding:10px 14px;
      border-radius:10px; box-shadow:var(--shadow);
      font-size:14px; z-index:3000; display:none;
      text-transform:none !important;
    }
    .toast.centered{
      top:50%; bottom:auto; left:50%;
      transform:translate(-50%,-50%);
    }

    .order-status-overlay{
      position:fixed; inset:0; z-index:3500;
      background:linear-gradient(180deg,var(--bg1) 0px,var(--bg1) calc(var(--topbar-h) + 1px),var(--bg2) 55%,var(--bg3) 100%);
      display:flex; align-items:center; justify-content:center;
    }
    .order-status-content{
      text-align:center; padding:var(--pad);
      max-width:var(--content-max);
    }
    .order-status-message{
      font-size:18px; margin-bottom:20px;
      color:var(--text); line-height:1.5;
    }

    .fs-backdrop{ position:fixed; inset:0; z-index:2500; background:rgba(0,0,0,0.15); display:none; }
    .fs-screen{
      position:fixed; inset:0; z-index:2510;
      display:none; flex-direction:column; color:var(--text);
      background:linear-gradient(180deg,var(--bg1) 0px,var(--bg1) calc(var(--topbar-h) + 1px),var(--bg2) 55%,var(--bg3) 100%);
      overflow:hidden;
    }
    .fs-screen header{
      height:var(--topbar-h);
      padding:8px var(--pad);
      font-weight:800;
      display:flex; align-items:center; justify-content:center;
      background:transparent;
    }
    .fs-screen .content{
      flex:1; display:flex; flex-direction:column; align-items:center; gap:12px;
      padding:12px var(--pad) calc(16px + env(safe-area-inset-bottom,0px));
      overflow:auto; -webkit-overflow-scrolling:touch;
      width:100%;
    }

    #dayBackdrop{ position:fixed; inset:0; z-index:2300; background:rgba(0,0,0,0.15); display:none; }
    #dayModal{
      position:fixed; inset:0; z-index:2310;
      display:none; flex-direction:column; color:var(--text);
      background:linear-gradient(180deg,var(--bg1) 0px,var(--bg1) calc(var(--topbar-h) + 1px),var(--bg2) 55%,var(--bg3) 100%);
      touch-action:pan-y; overflow:hidden;
    }
    #dayModal header{ height:var(--topbar-h); padding:8px var(--pad); font-weight:800; display:flex; align-items:center; justify-content:center; }
    #dayTitleText{ font-size:var(--title-size); font-weight:800; letter-spacing:1.5px; line-height:1.2; text-align:center; }
    #dayContent{ flex:1; padding:0; display:flex; flex-direction:column; overflow-y:auto; -webkit-overflow-scrolling:touch; }

    .sheet-inner{ width:100%; max-width:720px; margin:0 auto; padding:12px var(--pad) calc(260px + env(safe-area-inset-bottom,0px)); display:flex; flex-direction:column; gap:20px; }

    .polaroid{
      width:96%; max-width:var(--content-max);
      margin:0 auto;
      background:#ffffff !important;
      color:#000000 !important;
      padding:var(--polaroid-border);
      padding-bottom:calc(var(--polaroid-border) * 2);
      border-radius:var(--polaroid-radius);
      position:relative;
      box-shadow:var(--shadow);
    }
    .polaroid-img-wrap{
      position:relative;
      width:100%; aspect-ratio:1/1;
      background:#f8f8f8;
      overflow:hidden;
      border-radius:var(--inner-radius);
      cursor:pointer;
      transition:opacity .15s;
    }
    .polaroid-img-wrap.disabled{ pointer-events:none; cursor:default; opacity:1 !important; filter:none !important; }
    .polaroid-img-wrap img{ position:absolute; inset:0; width:100%; height:100%; object-fit:cover; display:none; }
    .polaroid-placeholder{ position:absolute; inset:0; display:grid; place-items:center; font-size:13px; font-weight:600; color:#000000 !important; opacity:.6; text-align:center; padding:10px; }
    .polaroid-summary{ margin-top:10px; font-size:13px; font-weight:600; text-align:center; line-height:1.4; white-space:pre-line; display:none; color:#000000 !important; }
    .polaroid.has-summary .polaroid-summary{ display:block; }
    .polaroid.solo-photo{ padding:var(--polaroid-border); }
    .polaroid.solo-photo .polaroid-summary{ display:none !important; }

    /* Viewer-only polaroid styling for saved day view modal */
    #dayModal .viewer-polaroid{
      /* Fixed height to match a fully filled polaroid */
      /* Calculation: image width + 136px */
      /* 136px = 6px (top padding) + 12px (bottom padding) + 118px (summary area for 8 lines) */
      height:calc(min(96vw, var(--content-max)) + 136px);
      display:flex;
      flex-direction:column;
    }
    #dayModal .viewer-polaroid .polaroid-img-wrap{
      /* Image area remains square */
      flex:0 0 auto;
      width:100%;
      aspect-ratio:1/1;
    }
    #dayModal .viewer-polaroid .polaroid-summary{
      /* Wrapper for vertically centering the summary text */
      flex:1;
      display:flex !important;
      align-items:center;
      justify-content:center;
      margin-top:0;
      padding:10px 6px;
    }

    .section-block,
    .note-section,
    .song-section,
    .movie-section,
    .show-section{
      width:100%; max-width:var(--content-max); margin:0 auto;
      background:var(--surface);
      border-radius:14px;
      box-shadow:var(--shadow);
      padding:14px 14px 18px;
      display:flex; flex-direction:column; gap:12px;
    }
    /* Notes tab: make bottom spacing equal to gap between header and textarea */
    #notesSectionNotes{
      padding-bottom:12px;
    }
    .section-header{ font-size:14px; font-weight:800; letter-spacing:1px; text-align:center; margin:0; }

    .notes{
      width:100%; border:none; outline:none; background:transparent; resize:none;
      font-family:inherit; font-size:var(--note-fs);
      line-height:1.35;
      text-align:center;
      overflow:hidden;
      padding:0 8px;
      color:var(--text);
    }
    .notes.mid-start{
      padding-top:0;
      white-space:pre-wrap;
      min-height:68px;
      max-height:68px;
      height:68px;
    }
    .notes.multiline{
      padding-top:0;
      white-space:pre-wrap;
      overflow:auto;
      min-height:158px;
      max-height:158px;
      height:auto;
    }

    .song-input{ width:100%; background:transparent; border:none; outline:none; font-family:inherit; font-size:14px; text-align:center; padding:0 8px; height:34px; color:var(--text); }

    .emoji-grid{ width:100%; display:grid; grid-template-columns:repeat(5,1fr); gap:var(--emoji-gap); }
    .emoji-chip{
      display:flex; align-items:center; justify-content:center;
      height:var(--emoji-size); font-size:22px; background:var(--surface);
      border-radius:12px; cursor:pointer; box-shadow:var(--shadow);
      user-select:none; transition:transform .12s;
    }
    .emoji-chip.selected{ outline:3px solid var(--outline-color); box-shadow:0 0 0 3px var(--outline-color)33, var(--shadow); transform:scale(0.95); }

    .custom-emoji-chip{
      display:flex; align-items:center; justify-content:center;
      height:var(--emoji-size);
      background:var(--surface);
      border-radius:12px; box-shadow:var(--shadow);
      padding:0 10px; cursor:text; position:relative;
    }
    .custom-emoji-chip input{
      width:100%; border:none; outline:none; background:transparent;
      font-family:inherit; font-size:22px; font-weight:700;
      text-align:center; letter-spacing:.5px; color:var(--text);
    }
    .custom-emoji-chip.selected{
      outline:3px solid var(--outline-color); box-shadow:0 0 0 3px var(--outline-color)33, var(--shadow);
    }

    .word-top-wrap{ width:100%; display:flex; justify-content:center; }
    .custom-word-chip{
      width:calc((100% - (2 * 10px)) / 3);
      height:var(--word-height);
      display:flex; align-items:center; justify-content:center;
      background:var(--surface); border-radius:14px; box-shadow:var(--shadow);
      padding:0 12px; cursor:text; position:relative;
    }
    .word-grid .custom-word-chip{ width:100%; }
    .custom-word-chip input{
      width:100%; border:none; outline:none; background:transparent;
      font-family:inherit; font-size:13px; font-weight:700;
      text-align:center; letter-spacing:.5px; color:var(--text);
    }
    .custom-word-chip.selected{ outline:3px solid var(--outline-color); box-shadow:0 0 0 3px var(--outline-color)33, var(--shadow); }

    .word-grid{ width:100%; display:grid; grid-template-columns:repeat(3,1fr); gap:10px; }
    .word-chip{
      display:flex; align-items:center; justify-content:center;
      height:var(--word-height); font-size:13px; font-weight:700;
      background:var(--surface); border-radius:14px; cursor:pointer; box-shadow:var(--shadow);
      user-select:none; line-height:1.15; transition:transform .12s;
      padding:0 6px; text-align:center;
    }
    .word-chip.selected{ outline:3px solid var(--outline-color); box-shadow:0 0 0 3px var(--outline-color)33, var(--shadow); transform:scale(0.95); }

    .action-btn{
      width:96%; max-width:var(--content-max); margin:0 auto;
      font-family:inherit; font-weight:800; font-size:15px;
      border:none; border-radius:14px; padding:14px 18px;
      cursor:pointer; letter-spacing:1px; display:block;
      transition:background .18s, transform .12s;
      background:var(--button-bg); color:var(--button-text); box-shadow:0 4px 10px rgba(0,0,0,0.12);
    }
    .action-btn:active{ transform:scale(.97); }
    .primary-btn{ background:var(--outline-color) !important; color:#ffffff !important; box-shadow:0 4px 12px rgba(0,0,0,0.18) !important; }

    .edit-tabs{
      width:96%; max-width:var(--content-max); margin:20px auto 0;
      display:flex; gap:8px; justify-content:center;
    }
    .edit-tab-btn{
      flex:1; max-width:240px;
      font-family:inherit; font-weight:800; font-size:14px;
      border:none; border-radius:14px; padding:12px 18px;
      cursor:pointer; letter-spacing:1px;
      transition:background .18s, transform .12s;
      background:var(--surface); color:var(--text); box-shadow:0 2px 6px rgba(0,0,0,0.08);
    }
    .edit-tab-btn:active{ transform:scale(.97); }
    .edit-tab-btn.selected{
      background:var(--outline-color); color:#ffffff; box-shadow:0 3px 8px rgba(0,0,0,0.15);
    }

    #editStandardPane{ display:contents; }
    #editNotesPane{ display:contents; }

    .hidden{ display:none !important; }

    .emoji-chip:focus-visible,
    .word-chip:focus-visible,
    .custom-word-chip:focus-within,
    .custom-emoji-chip:focus-within,
    .action-btn:focus-visible,
    .choice-btn:focus-visible{
      outline:3px solid var(--outline-color);
    }

    #frameBackdrop{ position:fixed; inset:0; z-index:2400; background:rgba(0,0,0,0.15); display:none; }
    #frameModal{
      position:fixed; inset:0; z-index:2410;
      display:none; flex-direction:column; color:var(--text);
      background:linear-gradient(180deg,var(--bg1) 0px,var(--bg1) calc(var(--topbar-h) + 1px),var(--bg2) 55%,var(--bg3) 100%);
      overflow:hidden;
    }
    #frameModal header{ height:var(--topbar-h); padding:8px var(--pad); font-weight:800; display:flex; align-items:center; justify-content:center; }
    #frameContent{ flex:1; display:flex; flex-direction:column; align-items:center; gap:16px; padding:12px var(--pad) calc(16px + env(safe-area-inset-bottom,0px)); overflow:auto; -webkit-overflow-scrolling:touch; }
    .frame-viewport{ position:relative; width:min(92vw, 520px); aspect-ratio:1/1; background:#000; border-radius:16px; overflow:hidden; touch-action:none; }
    .frame-viewport img{ position:absolute; top:0; left:0; transform-origin:0 0; will-change:transform; user-select:none; -webkit-user-drag:none; pointer-events:none; }
    .frame-actions{ width:100%; max-width:520px; display:flex; flex-direction:column; gap:10px; }
    .frame-actions button{ width:100%; background:var(--surface); color:var(--text); border:none; border-radius:14px; padding:14px; font-weight:800; letter-spacing:1px; box-shadow:0 4px 10px rgba(0,0,0,0.12); }
    .frame-actions .primary{ background:var(--outline-color); color:#fff; box-shadow:0 4px 12px rgba(0,0,0,0.15); }

    .choice-btn{
      width:96%; max-width:520px;
      background:var(--surface); color:var(--text);
      border:none; border-radius:14px; padding:14px;
      font-weight:800; letter-spacing:1px; box-shadow:0 4px 10px rgba(0,0,0,0.12);
      cursor:pointer; position:relative;
      transition:transform .12s;
    }
    .choice-btn:active{ transform:scale(.97); }
    .choice-btn.selected{
      outline:3px solid var(--outline-color);
      box-shadow:0 0 0 3px var(--outline-color)33, var(--shadow);
    }

    #yearOptions{
      width:100%;
      max-width:560px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:12px;
    }

    #storeYearButtons,
    #storeMonthButtons,
    #storeDateButtons{
      width:100%;
      max-width:var(--content-max);
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:12px;
    }

    .cart-items-wrap{
      width:100%;
      max-width:var(--content-max);
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .cart-item{
      display:flex;
      align-items:center;
      gap:12px;
      background:var(--surface);
      padding:10px 12px;
      border-radius:14px;
      box-shadow:var(--shadow);
      width:100%;
      position:relative;
      padding-left:52px;
      padding-right:72px;
    }
    .cart-price{
      font-weight:800;
      font-size:14px;
      flex:0 0 auto;
      position:absolute;
      right:12px;
      top:50%;
      transform:translateY(-50%);
    }

    #storePolaroidCard{ border-radius:0 !important; }
    #storePolaroidCard .polaroid-img-wrap{ border-radius:0 !important; }

    #storePosterCard{
      width:96%; max-width:var(--content-max);
      margin:0 auto;
      background:transparent !important;
      padding:0 !important;
      border-radius:0 !important;
      box-shadow:none !important;
    }
    #storePosterCard .poster-img-wrap{
      width:100%;
      max-width:100%;
      margin:0;
      padding:0;
      background:transparent;
      display:flex;
      justify-content:center;
      align-items:center;
    }
    .poster-square{
      width:100%;
      aspect-ratio:1/1;
      position:relative;
      overflow:hidden;
      box-shadow:0 8px 24px rgba(0,0,0,0.22), 0 4px 10px rgba(0,0,0,0.15);
      background:var(--bg1);
    }
    .poster-square .month{
      visibility:hidden;
    }
    .poster-title-overlay{
      position:absolute;
      left:50%;
      transform:translateX(-50%);
      font-weight:800;
      letter-spacing:1.2px;
      text-align:center;
      color:var(--text);
      line-height:1.2;
      pointer-events:none;
      white-space:nowrap;
      font-family:var(--app-font);
      font-size:20px;
      visibility:hidden;
    }
    #storePosterCard .month{
      width:100%;
      padding:0;
      margin:0;
    }
    #storePosterCard .month h2{
      margin-top:0;
    }

    .cart-polaroid-img{
      width:200px; height:auto; display:block; border-radius:0 !important;
      margin:0 auto;
      background:#ffffff;
      object-fit:cover;
    }
    .cart-item.poster-item .cart-polaroid-img{
      width:200px;
      height:200px;
      object-fit:cover;
    }

    .cart-del-btn{
      width:36px; height:36px;
      display:grid; place-items:center;
      background:transparent; border:none; padding:0; cursor:pointer;
      color:var(--text);
      flex:0 0 auto;
      position:absolute;
      left:10px;
      top:50%;
      transform:translateY(-50%);
    }
    .cart-del-btn svg{
      width:18px; height:18px;
      stroke:currentColor; fill:none; stroke-width:1.8;
      stroke-linecap:round; stroke-linejoin:round;
    }

    #storePolaroidFS #storePolaroidCard{
      --store-polaroid-border:12px;
      padding:var(--store-polaroid-border);
      display:flex;
      flex-direction:column;
      aspect-ratio:2/3;
      box-sizing:border-box;
      background:#ffffff !important;
      position:relative;
    }
    #storePolaroidFS #storePolaroidImgWrap{
      flex:0 0 auto;
      width:100%;
      aspect-ratio:1/1;
      border-radius:0;
      background:#f8f8f8;
      margin:0;
    }
    #storePolaroidFS #storePolaroidSummary{
      position:absolute;
      left:50%;
      transform:translateX(-50%);
      margin:0;
      padding:0 6px;
      text-align:center;
      line-height:1.4;
      font-size:13px;
      font-weight:600;
      white-space:pre;
      word-break:keep-all;
      overflow-wrap:normal;
    }

    .product-description{
      width:96%;
      max-width:var(--content-max);
      margin:4px auto 8px;
      font-size:15px;
      font-weight:800;
      line-height:1.25;
      text-align:center;
      color:var(--text);
      white-space:normal;
    }

    .agree-row{
      width:96%;
      max-width:var(--content-max);
      margin:4px auto 0;
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:13px;
      font-weight:600;
      line-height:1.3;
      position:relative;
    }
    .agree-text{
      flex:1;
      padding-right:12px;
      text-align:left;
    }
    .agree-box{
      width:22px;
      height:22px;
      border:2px solid var(--outline-color);
      border-radius:6px;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:800;
      font-size:16px;
      user-select:none;
      background:transparent;
      color:var(--outline-color);
    }
    .agree-box.checked{
      background:var(--outline-color);
      color:#ffffff;
    }

    #deleteDataBackdrop{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,0.35);
      z-index:3000;
      display:none;
    }
    #deleteDataDialog{
      position:fixed;
      top:50%; left:50%;
      transform:translate(-50%,-50%);
      width:90%;
      max-width:420px;
      background:var(--surface);
      color:var(--text);
      border-radius:18px;
      box-shadow:0 8px 28px rgba(0,0,0,0.25), 0 2px 8px rgba(0,0,0,0.15);
      padding:26px 20px 22px;
      display:none;
      z-index:3010;
      text-align:center;
      font-family:var(--app-font);
    }
    #deleteDataDialog h3{
      margin:0 0 14px;
      font-size:16px;
      font-weight:800;
      letter-spacing:1px;
    }
    #deleteDataDialog p{
      margin:0 0 20px;
      font-size:14px;
      font-weight:600;
      line-height:1.4;
      white-space:pre-line;
    }
    .dialog-actions{
      display:flex;
      flex-wrap:wrap;
      gap:14px;
      justify-content:center;
    }
    .dialog-actions button{
      flex:1 1 140px;
      font-family:inherit;
      font-weight:800;
      font-size:14px;
      letter-spacing:1px;
      padding:14px 16px;
      border:none;
      border-radius:14px;
      cursor:pointer;
      background:var(--surface);
      color:var(--text);
      box-shadow:0 4px 10px rgba(0,0,0,0.12);
      transition:transform .12s;
      text-transform:inherit;
    }
    .dialog-actions button:active{ transform:scale(.96); }
    .dialog-actions button.confirm{
      background:var(--outline-color);
      color:#ffffff;
      box-shadow:0 4px 12px rgba(0,0,0,0.18);
    }

    #welcomeModalBackdrop{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,0.3);
      z-index:2600;
      display:none;
    }
    #welcomeModal{
      position:fixed;
      top:50%; left:50%;
      transform:translate(-50%,-50%);
      width:90%;
      max-width:520px;
      background:var(--surface);
      color:var(--text);
      border-radius:18px;
      box-shadow:0 8px 28px rgba(0,0,0,0.25), 0 2px 8px rgba(0,0,0,0.15);
      padding:26px 20px 22px;
      display:none;
      z-index:2610;
      text-align:center;
      font-family:var(--app-font);
    }
    #welcomeModal h3{
      margin:0 0 18px;
      font-size:18px;
      font-weight:800;
      letter-spacing:1.5px;
    }
    #welcomeModal p{
      margin:0 0 20px;
      font-size:15px;
      font-weight:800;
      line-height:1.35;
    }
    #welcomeModal button{
      width:100%;
      font-family:inherit;
      font-weight:800;
      font-size:15px;
      letter-spacing:1px;
      padding:14px 18px;
      border:none;
      border-radius:14px;
      cursor:pointer;
      background:var(--outline-color);
      color:#ffffff;
      box-shadow:0 4px 12px rgba(0,0,0,0.18);
      transition:transform .12s;
    }
    #welcomeModal button:active{ transform:scale(.96); }
  </style>
  <script>
    (function(){
      try{
        const THEME_KEY='app-theme-key';
        const FONT_KEY='app-font-key';
        const THEMES=['pastel','dark','light','galaxy','sunset','forest','underwater','rainbow','fire','earth'];
        const FONT_MAP={
          roboto: '"Roboto",system-ui,-apple-system,"Segoe UI",sans-serif',
          poppins: '"Poppins",system-ui,-apple-system,"Segoe UI",sans-serif',
          merriweather: '"Merriweather",Georgia,serif',
          dancingscript: '"Dancing Script",cursive',
          boogaloo: '"Boogaloo",cursive',
          caveat: '"Caveat",cursive',
          indieflower: '"Indie Flower",cursive',
          jersey10: '"Jersey 10",cursive'
        };
        const ICON_STROKE_MAP={
          dancingscript:1.6,
          boogaloo:1.6,
          caveat:1.6,
          indieflower:1.6,
          jersey10:1.6,
          default:2.2
        };
        
        let themeKey=localStorage.getItem(THEME_KEY) || 'galaxy';
        if(!THEMES.includes(themeKey)) themeKey='galaxy';
        document.documentElement.setAttribute('data-theme', themeKey);
        
        let fontKey=localStorage.getItem(FONT_KEY) || 'roboto';
        if(!FONT_MAP[fontKey]) fontKey='roboto';
        document.documentElement.style.setProperty('--app-font', FONT_MAP[fontKey]);
        const stroke = ICON_STROKE_MAP[fontKey] || ICON_STROKE_MAP.default;
        document.documentElement.style.setProperty('--icon-stroke', stroke);
      }catch(e){}
    })();
  </script>
</head>
<body>
  <div class="topbar" id="topbar">
    <button class="icon-btn" id="cartBtn" aria-label="cart">
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M15 18l-6-6 6-6" />
      </svg>
    </button>
    <div class="title" id="yearTitle" title="change calendar">2025</div>
    <button class="icon-btn" id="settingsBtn" aria-label="settings">
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M9 18l6-6-6-6" />
      </svg>
    </button>
  </div>

  <div class="app" id="app">
    <div id="calCarousel" class="cal-carousel">
      <div class="cal-page" id="calPhoto"></div>
      <div class="cal-page" id="calEmoji"></div>
    </div>
  </div>

  <input type="file" id="chooserInput" accept="image/*" style="display:none" />
  <div class="toast" id="toast"></div>

  <div class="order-status-overlay" id="orderStatusOverlay" style="display:none;">
    <div class="order-status-content">
      <div class="order-status-message" id="orderStatusMessage">processing your order‚Ä¶</div>
      <button class="action-btn" id="orderStatusBackBtn" style="display:none;">back to calendar</button>
    </div>
  </div>

  <div id="welcomeModalBackdrop"></div>
  <div id="welcomeModal" role="dialog" aria-modal="true" aria-labelledby="welcomeModalTitle">
    <h3 id="welcomeModalTitle">Welcome!</h3>
    <p id="welcomeModalText" data-caps-sentence>the memory calendar is a place for journaling, saving memories and creating art. there are no ads or in-app purchases but there is an in-app store where you can purchase your beautiful custom daily polaroids and monthly posters. as a solo passion project, every purchase is greatly appreciated and helps in future developments!</p>
    <button id="welcomeContinueBtn">continue</button>
  </div>

  <div class="fs-backdrop" id="aboutFSBackdrop"></div>
  <div class="fs-screen" id="aboutFS" role="dialog" aria-modal="true" aria-labelledby="aboutFSTitle" style="display:none;">
    <header id="aboutFSTitle">about</header>
    <div class="content">
      <p class="product-description" id="aboutParagraph" data-caps-sentence>the memory calendar is a place for journaling, saving memories and creating art. there are no ads or in-app purchases but there is an in-app store where you can purchase your beautiful custom daily polaroids and monthly posters. as a solo passion project, every purchase is greatly appreciated and helps in future developments!</p>
      <button class="action-btn" id="aboutBackBtn">back</button>
    </div>
  </div>

  <div class="fs-backdrop" id="settingsFSBackdrop"></div>
  <div class="fs-screen" id="settingsFS" role="dialog" aria-modal="true" aria-labelledby="settingsFSTitle">
    <header id="settingsFSTitle">settings</header>
    <div class="content">
      <button class="action-btn" id="openCapsBtn">caps</button>
      <button class="action-btn" id="openFontsBtn">fonts</button>
      <button class="action-btn" id="openThemesBtn">themes</button>
      <button class="action-btn" id="openCurrencyBtn">currency</button>
      <button class="action-btn" id="openReportBtn">report an issue</button>
      <button class="action-btn" id="openAboutBtn">about</button>
      <button class="action-btn" id="openTermsBtn">terms & conditions</button>
      <button class="action-btn" id="openPrivacyBtn">privacy policy</button>
      <button class="action-btn" id="restorePurchasesBtn" style="display:none">restore my purchases</button>
      <button class="action-btn" id="deleteDataBtn">delete my data</button>
      <button class="action-btn" id="settingsBackBtn">back</button>
    </div>
  </div>

  <div id="deleteDataBackdrop"></div>
  <div id="deleteDataDialog" role="alertdialog" aria-modal="true" aria-labelledby="deleteDataTitle">
    <h3 id="deleteDataTitle">delete all data?</h3>
    <p id="deleteDataMessage">all of your data will be deleted, would you like to continue?</p>
    <div class="dialog-actions">
      <button id="deleteCancelBtn">cancel</button>
      <button id="deleteConfirmBtn" class="confirm">confirm</button>
    </div>
  </div>

  <div class="fs-backdrop" id="capsFSBackdrop"></div>
  <div class="fs-screen" id="capsFS" role="dialog" aria-modal="true" aria-labelledby="capsFSTitle">
    <header id="capsFSTitle">caps</header>
    <div class="content">
      <button class="choice-btn fixed-case-none" id="capsNoneBtn">none</button>
      <button class="choice-btn fixed-case-standard" id="capsStandardBtn">Standard</button>
      <button class="choice-btn fixed-case-all" id="capsAllBtn">ALL</button>
      <button class="action-btn" id="capsBackBtn">back</button>
    </div>
  </div>

  <div class="fs-backdrop" id="fontsFSBackdrop"></div>
  <div class="fs-screen" id="fontsFS" role="dialog" aria-modal="true" aria-labelledby="fontsFSTitle">
    <header id="fontsFSTitle">fonts</header>
    <div class="content" id="fontsContent">
      <button class="choice-btn font-choice" data-font="roboto" style="font-family:'Roboto',sans-serif;">Roboto</button>
      <button class="choice-btn font-choice" data-font="poppins" style="font-family:'Poppins',sans-serif;">Poppins</button>
      <button class="choice-btn font-choice" data-font="merriweather" style="font-family:'Merriweather',serif;">Merriweather</button>
      <button class="choice-btn font-choice" data-font="dancingscript" style="font-family:'Dancing Script',cursive;">Dancing Script</button>
      <button class="choice-btn font-choice" data-font="boogaloo" style="font-family:'Boogaloo',cursive;">Boogaloo</button>
      <button class="choice-btn font-choice" data-font="caveat" style="font-family:'Caveat',cursive;">Caveat</button>
      <button class="choice-btn font-choice" data-font="indieflower" style="font-family:'Indie Flower',cursive;">Indie Flower</button>
      <button class="choice-btn font-choice" data-font="jersey10" style="font-family:'Jersey 10',cursive;">Jersey 10</button>
      <button class="action-btn" id="fontsBackBtn">back</button>
    </div>
  </div>

  <div class="fs-backdrop" id="themesFSBackdrop"></div>
  <div class="fs-screen" id="themesFS" role="dialog" aria-modal="true" aria-labelledby="themesFSTitle">
    <header id="themesFSTitle">themes</header>
    <div class="content" id="themesContent">
      <button class="choice-btn theme-choice" data-theme="galaxy">galaxy</button>
      <button class="choice-btn theme-choice" data-theme="fire">fire</button>
      <button class="choice-btn theme-choice" data-theme="earth">earth</button>
      <button class="choice-btn theme-choice" data-theme="sunset">sunset</button>
      <button class="choice-btn theme-choice" data-theme="pastel">pastel</button>
      <button class="choice-btn theme-choice" data-theme="forest">forest</button>
      <button class="choice-btn theme-choice" data-theme="underwater">underwater</button>
      <button class="choice-btn theme-choice" data-theme="rainbow">rainbow</button>
      <button class="choice-btn theme-choice" data-theme="light">light</button>
      <button class="choice-btn theme-choice" data-theme="dark">dark</button>
      <button class="action-btn" id="themesBackBtn">back</button>
    </div>
  </div>

  <div class="fs-backdrop" id="currencyFSBackdrop"></div>
  <div class="fs-screen" id="currencyFS" role="dialog" aria-modal="true" aria-labelledby="currencyFSTitle" style="display:none;">
    <header id="currencyFSTitle">currency</header>
    <div class="content" id="currencyContent">
      <button class="choice-btn currency-choice" data-currency="eur">euros (‚Ç¨)</button>
      <button class="choice-btn currency-choice" data-currency="gbp">british pounds (¬£)</button>
      <button class="choice-btn currency-choice" data-currency="usd">united states dollars ($)</button>
      <button class="choice-btn currency-choice" data-currency="cad">canadian dollars (C$)</button>
      <button class="choice-btn currency-choice" data-currency="aud">australian dollars (A$)</button>
      <button class="action-btn" id="currencyBackBtn">back</button>
    </div>
  </div>

  <div class="fs-backdrop" id="reportFSBackdrop"></div>
  <div class="fs-screen" id="reportFS" role="dialog" aria-modal="true" aria-labelledby="reportFSTitle" style="display:none;">
    <header id="reportFSTitle">report an issue</header>
    <div class="content" id="reportContent">
      <p class="product-description">Please contact thememorycalendar@gmail.com</p>
      <button class="action-btn" id="reportBackBtn">back</button>
    </div>
  </div>

  <div class="fs-backdrop" id="storeFSBackdrop"></div>
  <div class="fs-screen" id="storeFS" role="dialog" aria-modal="true" aria-labelledby="storeFSTitle" style="display:none;">
    <header id="storeFSTitle">store</header>
    <div class="content" id="storeContent">
      <button class="action-btn" id="storeCartBtn">cart</button>
      <button class="action-btn" id="storeDayPolaroidBtn">daily polaroid</button>
      <button class="action-btn" id="storeMonthPosterBtn">monthly poster</button>
      <button class="action-btn" id="storeBackBtn">back</button>
    </div>
  </div>

  <div class="fs-backdrop" id="storeYearBackdrop"></div>
  <div class="fs-screen" id="storeYearFS" role="dialog" aria-modal="true" aria-labelledby="storeYearTitle" style="display:none;">
    <header id="storeYearTitle">choose your year</header>
    <div class="content" id="storeYearContent">
      <div id="storeYearButtons"></div>
      <button class="action-btn" id="storeYearBackBtn">back</button>
    </div>
  </div>

  <div class="fs-backdrop" id="storeMonthBackdrop"></div>
  <div class="fs-screen" id="storeMonthFS" role="dialog" aria-modal="true" aria-labelledby="storeMonthTitle" style="display:none;">
    <header id="storeMonthTitle">choose your month</header>
    <div class="content" id="storeMonthContent">
      <div id="storeMonthButtons"></div>
      <button class="action-btn" id="storeMonthBackBtn">back</button>
    </div>
  </div>

  <div class="fs-backdrop" id="storeDateBackdrop"></div>
  <div class="fs-screen" id="storeDateFS" role="dialog" aria-modal="true" aria-labelledby="storeDateTitle" style="display:none;">
    <header id="storeDateTitle">choose your day</header>
    <div class="content" id="storeDateContent">
      <div id="storeDateButtons"></div>
      <button class="action-btn" id="storeDateBackBtn">back</button>
    </div>
  </div>

  <div class="fs-backdrop" id="storePolaroidBackdrop"></div>
  <div class="fs-screen" id="storePolaroidFS" role="dialog" aria-modal="true" aria-labelledby="storePolaroidTitle" style="display:none;">
    <header id="storePolaroidTitle">daily polaroid</header>
    <div class="content" id="storePolaroidContent">
      <div class="polaroid" id="storePolaroidCard">
        <div class="polaroid-img-wrap" id="storePolaroidImgWrap">
          <img id="storePolaroidImg" alt="day polaroid">
          <div class="polaroid-placeholder" id="storePolaroidPlaceholder" style="display:none;"></div>
        </div>
        <div class="polaroid-summary" id="storePolaroidSummary"></div>
      </div>
      <p class="product-description" id="storePolaroidDescription">turn your daily memories into art with a high-quality polaroid-style 6x4" photo print</p>
      <button class="action-btn" id="storePolaroidBuyBtn">‚Ç¨2.99</button>
      <button class="action-btn" id="storePolaroidBackBtn">back</button>
    </div>
  </div>

  <div class="fs-backdrop" id="storePosterBackdrop"></div>
  <div class="fs-screen" id="storePosterFS" role="dialog" aria-modal="true" aria-labelledby="storePosterTitle" style="display:none;">
    <header id="storePosterTitle">monthly poster</header>
    <div class="content" id="storePosterContent">
      <div id="storePosterCard">
        <div class="poster-img-wrap" id="storePosterImgWrap">
          <img id="storePosterImg" alt="month poster" style="display:none">
        </div>
      </div>
      <p class="product-description" id="storePosterDescription">turn your monthly memories into art with a high-quality 30√ó30cm poster print</p>
      <button class="action-btn" id="storePosterBuyBtn">‚Ç¨9.99</button>
      <button class="action-btn" id="storePosterBackBtn">back</button>
    </div>
  </div>

  <div class="fs-backdrop" id="storeCartBackdrop"></div>
  <div class="fs-screen" id="storeCartFS" role="dialog" aria-modal="true" aria-labelledby="storeCartTitle" style="display:none;">
    <header id="storeCartTitle">cart</header>
    <div class="content" id="storeCartContent">
      <div class="cart-items-wrap" id="cartItemsList"></div>
      <div class="cart-item" id="deliveryFeeRow" style="padding-left:12px;">
        <div id="deliveryFeeLabel" style="font-weight:800; font-size:14px;">delivery fee</div>
        <div class="cart-price" id="deliveryFeePrice">‚Ç¨4.99</div>
      </div>
      <div id="deliveryEstimateContainer" style="width:96%; max-width:var(--content-max); margin:12px auto; font-size:13px; font-weight:600; text-align:center; opacity:0.8;"></div>
      <button class="action-btn" id="storeCartTotalBtn">total ‚Ç¨0.00</button>
      <button class="action-btn" id="storeCartBackBtn">back</button>
    </div>
  </div>

  <div class="fs-backdrop" id="checkoutFSBackdrop"></div>
  <div class="fs-screen" id="checkoutFS" role="dialog" aria-modal="true" aria-labelledby="checkoutFSTitle" style="display:none;">
    <header id="checkoutFSTitle">checkout</header>
    <div class="content" id="checkoutContent">
      <input class="action-btn" id="checkoutFirstName" placeholder="first name" maxlength="40">
      <input class="action-btn" id="checkoutLastName" placeholder="last name" maxlength="40">
      <input class="action-btn" id="checkoutEmail" placeholder="email" maxlength="120" inputmode="email">
      <input class="action-btn" id="checkoutPhone" placeholder="phone number" maxlength="30" inputmode="tel">
      <input class="action-btn" id="checkoutStreet" placeholder="street address" maxlength="120">
      <input class="action-btn" id="checkoutCity" placeholder="city" maxlength="60">
      <input class="action-btn" id="checkoutState" placeholder="state/province" maxlength="60">
      <input class="action-btn" id="checkoutPostal" placeholder="postal code" maxlength="20" inputmode="text">
      <input class="action-btn" id="checkoutCountry" placeholder="country" maxlength="60">

      <div class="agree-row" id="tncRow">
        <div class="agree-text">I have read and agree to the terms & conditions</div>
        <div class="agree-box" id="tncBox" aria-label="agree to terms" role="checkbox" aria-checked="false"></div>
      </div>
      <div class="agree-row" id="nonRefundRow">
        <div class="agree-text">I understand that all prints are custom-made and are non-refundable unless defective</div>
        <div class="agree-box" id="nonRefundBox" aria-label="acknowledge custom-made" role="checkbox" aria-checked="false"></div>
      </div>

      <button class="action-btn primary-btn" id="orderAndPayBtn" style="margin-top:12px;">order and pay ‚Äì ‚Ç¨0.00</button>
      <button class="action-btn" id="checkoutBackBtn">back</button>
    </div>
  </div>

  <div class="fs-backdrop" id="yearBackdrop"></div>
  <div id="yearModal" class="fs-screen" role="dialog" aria-modal="true" aria-labelledby="yearPickerTitle" style="display:none;">
    <header id="yearPickerTitle">choose your calendar</header>
    <div class="content" id="yearContent">
      <div id="yearOptions"></div>
      <button class="action-btn" id="yearBackBtn">back</button>
    </div>
  </div>

  <div class="modal-backdrop" id="dayBackdrop"></div>
  <div id="dayModal" role="dialog" aria-modal="true" style="display:none">
    <header><span id="dayTitleText">date</span></header>
    <div class="content" id="dayContent">
      <div class="sheet-inner">
        <div class="polaroid" id="polaroid">
          <div class="polaroid-img-wrap" id="polaroidImgWrap">
            <img id="bigPreviewImg" alt="selected day photo" decoding="sync" loading="eager">
            <div class="polaroid-placeholder" id="bigPreviewPlaceholder">tap to add a photo</div>
          </div>
          <div class="polaroid-summary" id="polaroidSummary"></div>
        </div>

        <div class="edit-tabs" id="editTabs" style="display:none;">
          <button class="edit-tab-btn" id="standardTabBtn" data-tab="standard">standard</button>
          <button class="edit-tab-btn" id="notesTabBtn" data-tab="notes">notes</button>
        </div>

        <div id="editStandardPane">
        <section class="note-section" id="noteSection">
          <h3 class="section-header">add your note of the day</h3>
          <textarea id="photoNotes" class="notes mid-start" rows="2" maxlength="80" aria-label="add your note of the day"></textarea>
        </section>

        <section class="section-block" id="wordSection">
          <h3 class="section-header">add your word of the day</h3>
          <div class="word-grid" id="wordGrid">
            <div class="word-chip" data-word="magical">magical</div>
            <div class="word-chip" data-word="joyful">joyful</div>
            <div class="word-chip" data-word="grateful">grateful</div>
            <div class="word-chip" data-word="inspired">inspired</div>
            <div class="word-chip" data-word="creative">creative</div>
            <div class="word-chip" data-word="peaceful">peaceful</div>
            <div class="word-chip" data-word="relaxed">relaxed</div>
            <div class="custom-word-chip" id="customWordChip">
              <input id="customWordInput" type="text" maxlength="30" aria-label="custom word">
            </div>
            <div class="word-chip" data-word="focused">focused</div>
            <div class="word-chip" data-word="busy">busy</div>
            <div class="word-chip" data-word="strange">strange</div>
            <div class="word-chip" data-word="heavy">heavy</div>
            <div class="word-chip" data-word="melancholic">melancholic</div>
            <div class="word-chip" data-word="anxious">anxious</div>
            <div class="word-chip" data-word="lost">lost</div>
          </div>
        </section>

        <section class="section-block" id="iconSection">
          <h3 class="section-header">add your icon of the day</h3>
          <div class="emoji-grid" id="emojiGrid">
            <div class="emoji-chip" data-emoji="üåø">üåø</div><div class="emoji-chip" data-emoji="üåô">üåô</div><div class="emoji-chip" data-emoji="‚ú®Ô∏è">‚ú®Ô∏è</div><div class="emoji-chip" data-emoji="‚òÄÔ∏è">‚òÄÔ∏è</div><div class="emoji-chip" data-emoji="üåß">üåß</div>
            <div class="emoji-chip" data-emoji="üòÑ">üòÑ</div><div class="emoji-chip" data-emoji="üòä">üòä</div><div class="emoji-chip" data-emoji="üòÇ">üòÇ</div><div class="emoji-chip" data-emoji="ü•≥">ü•≥</div><div class="emoji-chip" data-emoji="ü•∞">ü•∞</div>
            <div class="emoji-chip" data-emoji="üòú">üòú</div><div class="emoji-chip" data-emoji="üò¥">üò¥</div><div class="custom-emoji-chip" id="customEmojiChip"><input id="customEmojiInput" type="text" maxlength="8" aria-label="custom icon" inputmode="text" autocomplete="off" autocapitalize="none" spellcheck="false"></div><div class="emoji-chip" data-emoji="üòê">üòê</div><div class="emoji-chip" data-emoji="üòµ‚Äçüí´">üòµ‚Äçüí´</div>
            <div class="emoji-chip" data-emoji="üò†">üò†</div><div class="emoji-chip" data-emoji="ü§ï">ü§ï</div><div class="emoji-chip" data-emoji="ü§í">ü§í</div><div class="emoji-chip" data-emoji="üò£">üò£</div><div class="emoji-chip" data-emoji="üò≠">üò≠</div>
            <div class="emoji-chip" data-emoji="üéâ">üéâ</div><div class="emoji-chip" data-emoji="üé®">üé®</div><div class="emoji-chip" data-emoji="‚òïÔ∏è">‚òïÔ∏è</div><div class="emoji-chip" data-emoji="‚ù§Ô∏è">‚ù§Ô∏è</div><div class="emoji-chip" data-emoji="üíî">üíî</div>
          </div>
        </section>

        <section class="song-section" id="songSection">
          <h3 class="section-header">add your song of the day</h3>
          <input id="songInput" class="song-input" type="text" maxlength="60" aria-label="song of the day">
        </section>

        <section class="movie-section" id="movieSection">
          <h3 class="section-header">add your movie of the day</h3>
          <input id="movieInput" class="song-input" type="text" maxlength="60" aria-label="movie of the day">
        </section>

        <section class="show-section" id="showSection">
          <h3 class="section-header">add your show of the day</h3>
          <input id="showInput" class="song-input" type="text" maxlength="60" aria-label="show of the day">
        </section>
        </div>

        <div id="editNotesPane" style="display:none;">
        <section class="note-section" id="notesSectionNotes">
          <h3 class="section-header">add your note of the day</h3>
          <textarea id="photoNotesNotes" class="notes multiline" rows="7" maxlength="280" aria-label="add your note of the day" style="white-space:pre-wrap; overflow:auto; text-align:center; line-height:1.35; height:auto; min-height:158px; max-height:158px;"></textarea>
        </section>

        <section class="section-block" id="iconSectionNotes">
          <h3 class="section-header">add your icon of the day</h3>
          <div class="emoji-grid" id="emojiGridNotes">
            <div class="emoji-chip" data-emoji="üåø">üåø</div><div class="emoji-chip" data-emoji="üåô">üåô</div><div class="emoji-chip" data-emoji="‚ú®Ô∏è">‚ú®Ô∏è</div><div class="emoji-chip" data-emoji="‚òÄÔ∏è">‚òÄÔ∏è</div><div class="emoji-chip" data-emoji="üåß">üåß</div>
            <div class="emoji-chip" data-emoji="üòÑ">üòÑ</div><div class="emoji-chip" data-emoji="üòä">üòä</div><div class="emoji-chip" data-emoji="üòÇ">üòÇ</div><div class="emoji-chip" data-emoji="ü•≥">ü•≥</div><div class="emoji-chip" data-emoji="ü•∞">ü•∞</div>
            <div class="emoji-chip" data-emoji="üòú">üòú</div><div class="emoji-chip" data-emoji="üò¥">üò¥</div><div class="custom-emoji-chip" id="customEmojiChipNotes"><input id="customEmojiInputNotes" type="text" maxlength="8" aria-label="custom icon" inputmode="text" autocomplete="off" autocapitalize="none" spellcheck="false"></div><div class="emoji-chip" data-emoji="üòê">üòê</div><div class="emoji-chip" data-emoji="üòµ‚Äçüí´">üòµ‚Äçüí´</div>
            <div class="emoji-chip" data-emoji="üò†">üò†</div><div class="emoji-chip" data-emoji="ü§ï">ü§ï</div><div class="emoji-chip" data-emoji="ü§í">ü§í</div><div class="emoji-chip" data-emoji="üò£">üò£</div><div class="emoji-chip" data-emoji="üò≠">üò≠</div>
            <div class="emoji-chip" data-emoji="üéâ">üéâ</div><div class="emoji-chip" data-emoji="üé®">üé®</div><div class="emoji-chip" data-emoji="‚òïÔ∏è">‚òïÔ∏è</div><div class="emoji-chip" data-emoji="‚ù§Ô∏è">‚ù§Ô∏è</div><div class="emoji-chip" data-emoji="üíî">üíî</div>
          </div>
        </section>
        </div>

        <button class="action-btn" id="saveDayBtn">save</button>
        <button class="action-btn hidden" id="editDayBtn">edit</button>
        <button class="action-btn" id="backBtn">back</button>

      </div>
    </div>
  </div>

  <div class="modal-backdrop" id="frameBackdrop"></div>
  <div id="frameModal" role="dialog" aria-modal="true" aria-labelledby="frameTitle" style="display:none">
    <header id="frameTitle">frame your photo</header>
    <div id="frameContent">
      <div class="frame-viewport" id="frameViewport">
        <img id="frameImg" alt="frame image">
      </div>
      <div class="frame-actions">
        <button id="frameUseBtn" class="primary">save</button>
        <button id="frameCancelBtn">cancel</button>
      </div>
    </div>
  </div>

  <script>
    (function(){
      const MIN_YEAR=2020, MAX_YEAR=2030;

      const topbarEl=document.getElementById('topbar');
      const yearTitleEl=document.getElementById('yearTitle');

      const carousel=document.getElementById('calCarousel');
      const calPhoto=document.getElementById('calPhoto');
      const calEmoji=document.getElementById('calEmoji');
      const toastEl=document.getElementById('toast');
      const orderStatusOverlay=document.getElementById('orderStatusOverlay');
      const orderStatusMessage=document.getElementById('orderStatusMessage');
      const orderStatusBackBtn=document.getElementById('orderStatusBackBtn');

      const yearBackdrop=document.getElementById('yearBackdrop');
      const yearModal=document.getElementById('yearModal');
      const yearOptions=document.getElementById('yearOptions');
      const yearBackBtn=document.getElementById('yearBackBtn');

      const chooserInput=document.getElementById('chooserInput');
      const dayBackdrop=document.getElementById('dayBackdrop');
      const dayModal=document.getElementById('dayModal');
      const dayTitleText=document.getElementById('dayTitleText');

      const polaroid=document.getElementById('polaroid');
      const polaroidImgWrap=document.getElementById('polaroidImgWrap');
      const bigPreviewImg=document.getElementById('bigPreviewImg');
      const bigPreviewPlaceholder=document.getElementById('bigPreviewPlaceholder');
      const polaroidSummary=document.getElementById('polaroidSummary');

      const photoNotes=document.getElementById('photoNotes');
      const emojiGrid=document.getElementById('emojiGrid');
      const wordGrid=document.getElementById('wordGrid');
      const customWordInput=document.getElementById('customWordInput');
      const customEmojiInput=document.getElementById('customEmojiInput');
      const songInput=document.getElementById('songInput');
      const movieInput=document.getElementById('movieInput');
      const showInput=document.getElementById('showInput');

      const saveDayBtn=document.getElementById('saveDayBtn');
      const editDayBtn=document.getElementById('editDayBtn');
      const backBtn=document.getElementById('backBtn');

      const editTabs=document.getElementById('editTabs');
      const standardTabBtn=document.getElementById('standardTabBtn');
      const notesTabBtn=document.getElementById('notesTabBtn');
      const editStandardPane=document.getElementById('editStandardPane');
      const editNotesPane=document.getElementById('editNotesPane');
      const photoNotesNotes=document.getElementById('photoNotesNotes');
      const emojiGridNotes=document.getElementById('emojiGridNotes');
      const customEmojiInputNotes=document.getElementById('customEmojiInputNotes');
      const customEmojiChipNotes=document.getElementById('customEmojiChipNotes');

      const settingsBtn=document.getElementById('settingsBtn');
      const settingsFSBackdrop=document.getElementById('settingsFSBackdrop');
      const settingsFS=document.getElementById('settingsFS');
      const openCapsBtn=document.getElementById('openCapsBtn');
      const openFontsBtn=document.getElementById('openFontsBtn');
      const openThemesBtn=document.getElementById('openThemesBtn');
      const openCurrencyBtn=document.getElementById('openCurrencyBtn');
      const openReportBtn=document.getElementById('openReportBtn');
      const openTermsBtn=document.getElementById('openTermsBtn');
      const openPrivacyBtn=document.getElementById('openPrivacyBtn');
      const openAboutBtn=document.getElementById('openAboutBtn');
      const deleteDataBtn=document.getElementById('deleteDataBtn');
      const settingsBackBtn=document.getElementById('settingsBackBtn');
      const restorePurchasesBtn=document.getElementById('restorePurchasesBtn');

      const welcomeModalBackdrop=document.getElementById('welcomeModalBackdrop');
      const welcomeModal=document.getElementById('welcomeModal');
      const welcomeModalText=document.getElementById('welcomeModalText');
      const welcomeContinueBtn=document.getElementById('welcomeContinueBtn');

      const aboutFSBackdrop=document.getElementById('aboutFSBackdrop');
      const aboutFS=document.getElementById('aboutFS');
      const aboutParagraph=document.getElementById('aboutParagraph');
      const aboutBackBtn=document.getElementById('aboutBackBtn');

      const currencyFSBackdrop=document.getElementById('currencyFSBackdrop');
      const currencyFS=document.getElementById('currencyFS');
      const currencyChoices=[...document.querySelectorAll('.currency-choice')];
      const currencyBackBtn=document.getElementById('currencyBackBtn');

      const deleteDataBackdrop=document.getElementById('deleteDataBackdrop');
      const deleteDataDialog=document.getElementById('deleteDataDialog');
      const deleteCancelBtn=document.getElementById('deleteCancelBtn');
      const deleteConfirmBtn=document.getElementById('deleteConfirmBtn');
      const deleteDataMessage=document.getElementById('deleteDataMessage');
      const deleteDataTitle=document.getElementById('deleteDataTitle');

      const capsFSBackdrop=document.getElementById('capsFSBackdrop');
      const capsFS=document.getElementById('capsFS');
      const capsNoneBtn=document.getElementById('capsNoneBtn');
      const capsStandardBtn=document.getElementById('capsStandardBtn');
      const capsAllBtn=document.getElementById('capsAllBtn');
      const capsBackBtn=document.getElementById('capsBackBtn');

      const fontsFSBackdrop=document.getElementById('fontsFSBackdrop');
      const fontsFS=document.getElementById('fontsFS');
      const fontsBackBtn=document.getElementById('fontsBackBtn');
      const fontsChoices=[...document.querySelectorAll('.font-choice')];

      const themesFSBackdrop=document.getElementById('themesFSBackdrop');
      const themesFS=document.getElementById('themesFS');
      const themesBackBtn=document.getElementById('themesBackBtn');
      const themeChoices=[...document.querySelectorAll('.theme-choice')];

      const reportFSBackdrop=document.getElementById('reportFSBackdrop');
      const reportFS=document.getElementById('reportFS');
      const reportBackBtn=document.getElementById('reportBackBtn');

      const cartBtn=document.getElementById('cartBtn');
      const storeFSBackdrop=document.getElementById('storeFSBackdrop');
      const storeFS=document.getElementById('storeFS');
      const storeDayPolaroidBtn=document.getElementById('storeDayPolaroidBtn');
      const storeMonthPosterBtn=document.getElementById('storeMonthPosterBtn');
      const storeBackBtn=document.getElementById('storeBackBtn');

      const storeYearBackdrop=document.getElementById('storeYearBackdrop');
      const storeYearFS=document.getElementById('storeYearFS');
      const storeYearButtons=document.getElementById('storeYearButtons');
      const storeYearBackBtn=document.getElementById('storeYearBackBtn');

      const storeMonthBackdrop=document.getElementById('storeMonthBackdrop');
      const storeMonthFS=document.getElementById('storeMonthFS');
      const storeMonthButtons=document.getElementById('storeMonthButtons');
      const storeMonthBackBtn=document.getElementById('storeMonthBackBtn');

      const storeDateBackdrop=document.getElementById('storeDateBackdrop');
      const storeDateFS=document.getElementById('storeDateFS');
      const storeDateButtons=document.getElementById('storeDateButtons');
      const storeDateBackBtn=document.getElementById('storeDateBackBtn');

      const storePolaroidBackdrop=document.getElementById('storePolaroidBackdrop');
      const storePolaroidFS=document.getElementById('storePolaroidFS');
      const storePolaroidImg=document.getElementById('storePolaroidImg');
      const storePolaroidImgWrap=document.getElementById('storePolaroidImgWrap');
      const storePolaroidPlaceholder=document.getElementById('storePolaroidPlaceholder');
      const storePolaroidSummary=document.getElementById('storePolaroidSummary');
      const storePolaroidBackBtn=document.getElementById('storePolaroidBackBtn');
      const storePolaroidTitle=document.getElementById('storePolaroidTitle');
      const storePolaroidBuyBtn=document.getElementById('storePolaroidBuyBtn');
      const storePolaroidDescription=document.getElementById('storePolaroidDescription');

      const frameModal=document.getElementById('frameModal');
      const frameImg=document.getElementById('frameImg');
      const frameViewport=document.getElementById('frameViewport');
      const frameUseBtn=document.getElementById('frameUseBtn');
      const frameCancelBtn=document.getElementById('frameCancelBtn');

      const storePosterBackdrop=document.getElementById('storePosterBackdrop');
      const storePosterFS=document.getElementById('storePosterFS');
      const storePosterImg=document.getElementById('storePosterImg');
      const storePosterBackBtn=document.getElementById('storePosterBackBtn');
      const storePosterTitle=document.getElementById('storePosterTitle');
      const storePosterBuyBtn=document.getElementById('storePosterBuyBtn');
      const storePosterDescription=document.getElementById('storePosterDescription');

      const storeCartBackdrop=document.getElementById('storeCartBackdrop');
      const storeCartFS=document.getElementById('storeCartFS');
      const storeCartBackBtn=document.getElementById('storeCartBackBtn');
      const cartItemsList=document.getElementById('cartItemsList');
      const storeCartBtn=document.getElementById('storeCartBtn');
      const storeCartTotalBtn=document.getElementById('storeCartTotalBtn');
      const deliveryFeeLabel=document.getElementById('deliveryFeeLabel');
      const deliveryFeePrice=document.getElementById('deliveryFeePrice');
      const deliveryEstimateContainer=document.getElementById('deliveryEstimateContainer');

      const checkoutFSBackdrop=document.getElementById('checkoutFSBackdrop');
      const checkoutFS=document.getElementById('checkoutFS');
      const checkoutBackBtn=document.getElementById('checkoutBackBtn');
      const orderAndPayBtn=document.getElementById('orderAndPayBtn');
      const tncBox=document.getElementById('tncBox');
      const nonRefundBox=document.getElementById('nonRefundBox');
      const checkoutFirstName=document.getElementById('checkoutFirstName');
      const checkoutLastName=document.getElementById('checkoutLastName');
      const checkoutEmail=document.getElementById('checkoutEmail');
      const checkoutPhone=document.getElementById('checkoutPhone');
      const checkoutStreet=document.getElementById('checkoutStreet');
      const checkoutCity=document.getElementById('checkoutCity');
      const checkoutState=document.getElementById('checkoutState');
      const checkoutPostal=document.getElementById('checkoutPostal');
      const checkoutCountry=document.getElementById('checkoutCountry');

      let storeMode='day';

      const CART_KEY='cart-items';
      let cartItems=loadCartItems();

      const YEAR_KEY='app-year-key';
      const CAPS_KEY='caps-mode';
      const FONT_KEY='app-font-key';
      const THEME_KEY='app-theme-key';
      const CURRENCY_KEY='app-currency-key';
      const WELCOME_SEEN_KEY='welcome-seen';

      const DELETE_MSG_BASE='all of your data will be deleted, would you like to continue?';
      const DELETE_TITLE_BASE='delete all data?';

      const PRODUCT_DAY_BASE=`bring your daily memories to life with a high-quality polaroid-style 6x4" photo print`;
      const PRODUCT_MONTH_BASE=`bring your monthly memories to life with a high-quality 30x30cm poster print`;

      const PRICES={
        polaroid:{eur:'‚Ç¨2.99', gbp:'¬£2.99', usd:'$3.99', cad:'C$5.99', aud:'A$5.99'},
        poster:{eur:'‚Ç¨9.99', gbp:'¬£8.99', usd:'$11.99', cad:'C$16.99', aud:'A$17.99'},
        delivery:{eur:'‚Ç¨4.99', gbp:'¬£4.99', usd:'$6.99', cad:'C$8.99', aud:'A$9.99'}
      };

      // High-quality export settings
      const EXPORT_SCALE_MULTIPLIER = 3; // 3x resolution for high-quality exports
      const EXPORT_QUALITY = 0.95; // WebP/JPEG quality (0-1)
      
      // Cache WebP support detection (test canvas created once)
      let webpSupported = null;
      const testCanvas = (() => {
        const c = document.createElement('canvas');
        c.width = c.height = 1;
        return c;
      })();
      
      function supportsWebP() {
        if (webpSupported !== null) return webpSupported;
        webpSupported = testCanvas.toDataURL('image/webp').startsWith('data:image/webp');
        return webpSupported;
      }
      
      // Helper function to convert canvas to data URL with optimal format
      function canvasToDataURL(canvas, quality = EXPORT_QUALITY) {
        if (supportsWebP()) {
          return canvas.toDataURL('image/webp', quality);
        } else {
          return canvas.toDataURL('image/png');
        }
      }
      
      // Helper function to convert canvas to blob with optimal format
      async function canvasToBlob(canvas, quality = EXPORT_QUALITY) {
        return new Promise((resolve, reject) => {
          try {
            const useWebP = supportsWebP(); // Cache format detection result
            const callback = (blob) => {
              if (blob) {
                resolve(blob);
              } else {
                const format = useWebP ? 'WebP' : 'PNG';
                reject(new Error(`Failed to create ${format} blob from canvas (dimensions: ${canvas.width}x${canvas.height})`));
              }
            };
            
            if (useWebP) {
              canvas.toBlob(callback, 'image/webp', quality);
            } else {
              canvas.toBlob(callback, 'image/png');
            }
          } catch (error) {
            reject(error);
          }
        });
      }

      // ============================================================================
      // IndexedDB for full-resolution photo storage
      // ============================================================================
      const IDB_NAME = 'memory-calendar';
      const IDB_STORE_NAME = 'photos';
      const IDB_VERSION = 1;
      
      let idbInstance = null;
      
      // Object URL cache for preventing memory leaks
      const photoObjectURLCache = {};
      
      /**
       * Open or create IndexedDB database
       * @returns {Promise<IDBDatabase>}
       */
      async function idbOpen() {
        if (idbInstance) return idbInstance;
        
        // Feature detect IndexedDB
        if (!window.indexedDB) {
          console.warn('IndexedDB not available in this browser');
          return Promise.reject(new Error('IndexedDB not supported'));
        }
        
        return new Promise((resolve, reject) => {
          try {
            const request = indexedDB.open(IDB_NAME, IDB_VERSION);
            
            request.onerror = () => {
              console.error('IndexedDB open error:', request.error);
              reject(new Error('Failed to open IndexedDB'));
            };
            
            request.onsuccess = () => {
              idbInstance = request.result;
              resolve(idbInstance);
            };
            
            request.onupgradeneeded = (event) => {
              const db = event.target.result;
              
              // Create object store if it doesn't exist
              if (!db.objectStoreNames.contains(IDB_STORE_NAME)) {
                db.createObjectStore(IDB_STORE_NAME, { keyPath: 'id' });
              }
            };
          } catch (error) {
            console.error('IndexedDB setup error:', error);
            reject(error);
          }
        });
      }
      
      /**
       * Store a photo Blob in IndexedDB
       * @param {string} dateKey - Date key (e.g., 'photo-2025-01-15')
       * @param {Blob} blob - Image Blob to store
       * @returns {Promise<void>}
       */
      async function idbPutPhoto(dateKey, blob) {
        try {
          const db = await idbOpen();
          
          return new Promise((resolve, reject) => {
            const transaction = db.transaction([IDB_STORE_NAME], 'readwrite');
            const store = transaction.objectStore(IDB_STORE_NAME);
            
            const request = store.put({
              id: dateKey,
              blob: blob,
              timestamp: Date.now()
            });
            
            request.onsuccess = () => resolve();
            request.onerror = () => reject(new Error('Failed to store photo in IndexedDB'));
          });
        } catch (error) {
          console.error('idbPutPhoto error:', error);
          throw error;
        }
      }
      
      /**
       * Store a thumbnail Blob in IndexedDB
       * @param {string} dateKey - Date key (e.g., 'photo-2025-01-15')
       * @param {Blob} blob - Thumbnail Blob to store
       * @returns {Promise<void>}
       */
      async function idbPutThumbnail(dateKey, blob) {
        // Store thumbnail with 'thumb-' prefix
        const thumbKey = `thumb-${dateKey}`;
        try {
          const db = await idbOpen();
          
          return new Promise((resolve, reject) => {
            const transaction = db.transaction([IDB_STORE_NAME], 'readwrite');
            const store = transaction.objectStore(IDB_STORE_NAME);
            
            const request = store.put({
              id: thumbKey,
              blob: blob,
              timestamp: Date.now()
            });
            
            request.onsuccess = () => resolve();
            request.onerror = () => reject(new Error('Failed to store thumbnail in IndexedDB'));
          });
        } catch (error) {
          console.error('idbPutThumbnail error:', error);
          throw error;
        }
      }
      
      /**
       * Retrieve a photo Blob from IndexedDB
       * @param {string} dateKey - Date key (e.g., 'photo-2025-01-15')
       * @returns {Promise<Blob|null>}
       */
      async function idbGetPhoto(dateKey) {
        try {
          const db = await idbOpen();
          
          return new Promise((resolve, reject) => {
            const transaction = db.transaction([IDB_STORE_NAME], 'readonly');
            const store = transaction.objectStore(IDB_STORE_NAME);
            
            const request = store.get(dateKey);
            
            request.onsuccess = () => {
              const result = request.result;
              resolve(result ? result.blob : null);
            };
            
            request.onerror = () => {
              console.error('idbGetPhoto error:', request.error);
              resolve(null); // Return null on error instead of rejecting
            };
          });
        } catch (error) {
          console.error('idbGetPhoto error:', error);
          return null;
        }
      }
      
      /**
       * Retrieve a thumbnail Blob from IndexedDB
       * @param {string} dateKey - Date key (e.g., 'photo-2025-01-15')
       * @returns {Promise<Blob|null>}
       */
      async function idbGetThumbnail(dateKey) {
        const thumbKey = `thumb-${dateKey}`;
        try {
          const db = await idbOpen();
          
          return new Promise((resolve, reject) => {
            const transaction = db.transaction([IDB_STORE_NAME], 'readonly');
            const store = transaction.objectStore(IDB_STORE_NAME);
            
            const request = store.get(thumbKey);
            
            request.onsuccess = () => {
              const result = request.result;
              resolve(result ? result.blob : null);
            };
            
            request.onerror = () => {
              console.error('idbGetThumbnail error:', request.error);
              resolve(null);
            };
          });
        } catch (error) {
          console.error('idbGetThumbnail error:', error);
          return null;
        }
      }
      
      /**
       * Delete a photo from IndexedDB
       * @param {string} dateKey - Date key (e.g., 'photo-2025-01-15')
       * @returns {Promise<void>}
       */
      async function idbDeletePhoto(dateKey) {
        try {
          const db = await idbOpen();
          
          return new Promise((resolve, reject) => {
            const transaction = db.transaction([IDB_STORE_NAME], 'readwrite');
            const store = transaction.objectStore(IDB_STORE_NAME);
            
            // Delete both full and thumbnail
            const deletePhoto = store.delete(dateKey);
            const deleteThumbnail = store.delete(`thumb-${dateKey}`);
            
            transaction.oncomplete = () => resolve();
            transaction.onerror = () => reject(new Error('Failed to delete photo from IndexedDB'));
          });
        } catch (error) {
          console.error('idbDeletePhoto error:', error);
          throw error;
        }
      }
      
      // ============================================================================
      // Photo compression utilities - aligned with requirements
      // ============================================================================
      // Full image compression: max 1600px, quality 0.82
      const FULL_MAX_DIMENSION = 1600;
      const FULL_QUALITY = 0.82;
      
      // Thumbnail compression: max 512px, quality 0.70 
      const THUMB_MAX_DIMENSION = 512;
      const THUMB_QUALITY = 0.70;
      
      /**
       * Compress an image to specific dimensions and quality
       * @param {string|Blob} input - Data URL or Blob to compress
       * @param {number} maxDimension - Maximum width/height
       * @param {number} quality - Compression quality (0-1)
       * @returns {Promise<Blob>} - Compressed Blob
       */
      async function compressImage(input, maxDimension, quality) {
        try {
          // Convert input to an Image element
          const img = new Image();
          
          if (typeof input === 'string') {
            // Input is a data URL
            img.src = input;
          } else if (input instanceof Blob) {
            // Input is a Blob - create object URL
            const objectUrl = URL.createObjectURL(input);
            img.src = objectUrl;
          } else {
            throw new Error('Invalid input type for compression');
          }
          
          // Wait for image to load
          await new Promise((resolve, reject) => {
            img.onload = resolve;
            img.onerror = () => reject(new Error('Failed to load image for compression'));
          });
          
          // Revoke object URL if we created one
          if (img.src.startsWith('blob:')) {
            URL.revokeObjectURL(img.src);
          }
          
          // Calculate scaled dimensions
          const { width, height } = img;
          const maxDim = Math.max(width, height);
          
          let targetWidth = width;
          let targetHeight = height;
          
          if (maxDim > maxDimension) {
            const scale = maxDimension / maxDim;
            targetWidth = Math.max(1, Math.round(width * scale));
            targetHeight = Math.max(1, Math.round(height * scale));
          }
          
          // Create canvas for compression
          const canvas = document.createElement('canvas');
          canvas.width = targetWidth;
          canvas.height = targetHeight;
          
          const ctx = canvas.getContext('2d', { alpha: false });
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          
          // Draw scaled image
          ctx.drawImage(img, 0, 0, targetWidth, targetHeight);
          
          // Export as Blob with WebP or JPEG
          return await canvasToBlob(canvas, quality);
        } catch (error) {
          console.error('Image compression error:', error);
          throw error;
        }
      }
      
      /**
       * Compress to full resolution (max 1600px @ 0.82 quality)
       * @param {string|Blob} input - Data URL or Blob
       * @returns {Promise<Blob>}
       */
      async function compressToFull(input) {
        return await compressImage(input, FULL_MAX_DIMENSION, FULL_QUALITY);
      }
      
      /**
       * Compress to thumbnail (max 512px @ 0.70 quality)
       * @param {string|Blob} input - Data URL or Blob
       * @returns {Promise<Blob>}
       */
      async function compressToThumbnail(input) {
        return await compressImage(input, THUMB_MAX_DIMENSION, THUMB_QUALITY);
      }
      
      /**
       * Compress to preview - alias for thumbnail (backward compatibility)
       * @param {string|Blob} input - Data URL or Blob to compress
       * @returns {Promise<string>} - Compressed data URL
       */
      async function compressToPreview(input) {
        try {
          // Use thumbnail compression for preview
          const blob = await compressToThumbnail(input);
          
          // Convert blob to data URL
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = () => reject(new Error('Failed to read blob as data URL'));
            reader.readAsDataURL(blob);
          });
        } catch (error) {
          console.error('Preview compression error:', error);
          // Return original input if compression fails
          if (typeof input === 'string') {
            return input;
          }
          throw error;
        }
      }
      
      /**
       * Convert a data URL to a Blob
       * @param {string} dataUrl - Data URL to convert
       * @returns {Blob}
       */
      function dataUrlToBlob(dataUrl) {
        const parts = dataUrl.split(',');
        if (parts.length < 2) {
          throw new Error('Invalid data URL format: missing comma separator');
        }
        
        const mimeMatch = parts[0].match(/:(.*?);/);
        if (!mimeMatch) {
          throw new Error('Invalid data URL format: missing MIME type');
        }
        const mime = mimeMatch[1];
        
        const bstr = atob(parts[1]);
        const n = bstr.length;
        const u8arr = new Uint8Array(n);
        
        for (let i = 0; i < n; i++) {
          u8arr[i] = bstr.charCodeAt(i);
        }
        
        return new Blob([u8arr], { type: mime });
      }

      let currencyCode = tryGet(CURRENCY_KEY) || 'eur';

      function loadCartItems(){
        try{
          const raw=localStorage.getItem(CART_KEY);
          if(!raw) return [];
          const arr=JSON.parse(raw);
          return Array.isArray(arr)?arr:[];
        }catch(e){ return []; }
      }
      function saveCartItems(){ try{ localStorage.setItem(CART_KEY, JSON.stringify(cartItems)); }catch(e){} }

      function currentDeliveryFeeNumber(){
        const str=PRICES.delivery[currencyCode]||PRICES.delivery.eur;
        return parseFloat(str.replace(/[^\d.]/g,''))||0;
      }

      function updateDeliveryFeeLabel(){
        if(!deliveryFeeLabel) return;
        if(capsMode==='standard') deliveryFeeLabel.textContent='Delivery';
        else if(capsMode==='all') deliveryFeeLabel.textContent='DELIVERY';
        else deliveryFeeLabel.textContent='delivery';
        if(deliveryFeePrice){
          deliveryFeePrice.textContent=PRICES.delivery[currencyCode]||PRICES.delivery.eur;
        }
        if(deliveryEstimateContainer){
          deliveryEstimateContainer.textContent=getEstimatedDeliveryRange();
        }
      }

      function resetScreenScroll(screenEl){
        try{
          window.scrollTo(0,0);
          document.documentElement.scrollTop = 0;
          document.body.scrollTop = 0;
          const content = screenEl && screenEl.querySelector('.content');
          if(content){ content.scrollTop = 0; }
        }catch(e){}
      }

      async function buildStorePolaroidSnapshot(){
        try{
          const storePolaroidCard=document.getElementById('storePolaroidCard');
          const storePolaroidImg=document.getElementById('storePolaroidImg');
          const storePolaroidSummary=document.getElementById('storePolaroidSummary');
          const rect=storePolaroidCard.getBoundingClientRect();
          const widthCSS=Math.max(1, Math.round(rect.width)||320);
          const targetHeight = Math.round(widthCSS * 3 / 2);
          const border=12;
          const imgW=widthCSS - 2*border;
          const imgH=imgW;
          const summaryText=(storePolaroidSummary.textContent||'').trim();
          const lines = summaryText ? summaryText.split('\n') : [];
          const sumFontSize = 13;
          const sumLineH = sumFontSize*1.4;
          const linesBlockHeight = lines.length * sumLineH;
          const usedHeightWithoutBottom = border + imgH + border;
          let bottomAreaHeight = targetHeight - usedHeightWithoutBottom;
          if(bottomAreaHeight < linesBlockHeight + border){
            bottomAreaHeight = linesBlockHeight + border;
          }
          const heightCSS = usedHeightWithoutBottom + bottomAreaHeight;
          
          // Helper function to render polaroid on canvas at given scale
          const renderPolaroid = async (canvas, scale) => {
            canvas.width=Math.round(widthCSS*scale);
            canvas.height=Math.round(heightCSS*scale);
            const ctx=canvas.getContext('2d', { alpha: false });
            ctx.scale(scale, scale);
            ctx.fillStyle='#ffffff';
            ctx.fillRect(0,0,widthCSS,heightCSS);
            const imgX=border, imgY=border;
            const src = storePolaroidImg && storePolaroidImg.src ? storePolaroidImg.src : '';
            // Check if src is a valid data URL, blob URL, or http(s) URL (not empty and not the page URL)
            const hasValidImage = src && (src.startsWith('data:') || src.startsWith('blob:') || src.startsWith('http://') || src.startsWith('https://')) && storePolaroidImg.style.display !== 'none';
            if(hasValidImage){
              const im = await new Promise((res,rej)=>{ const i=new Image(); i.onload=()=>res(i); i.onerror=rej; i.src=src; });
              const iw=im.naturalWidth||im.width;
              const ih=im.naturalHeight||im.height;
              const r=Math.max(imgW/iw, imgH/ih);
              const dw=iw*r, dh=ih*r;
              const dx=imgX - (dw - imgW)/2;
              const dy=imgY - (dh - imgH)/2;
              ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high';
              ctx.drawImage(im, dx, dy, dw, dh);
            }else{
              ctx.fillStyle='#f0f0f0';
              ctx.fillRect(imgX,imgY,imgW,imgH);
            }
            ctx.fillStyle='#000000';
            const family=getComputedStyle(document.body).fontFamily || 'Comfortaa, sans-serif';
            ctx.font=`600 ${sumFontSize}px ${family}`;
            ctx.textAlign='center';
            ctx.textBaseline='middle';
            const summaryAreaTop = imgY + imgH + border;
            const summaryAreaHeight = bottomAreaHeight - border;
            const startCenterY = summaryAreaTop + (summaryAreaHeight/2) - (linesBlockHeight/2) + (sumLineH/2);
            lines.forEach((line, i)=>{
              ctx.fillText(line, widthCSS/2, startCenterY + i*sumLineH);
            });
          };
          
          // Create high-quality version for backend upload
          const exportScale = EXPORT_SCALE_MULTIPLIER;
          const highQualityCanvas=document.createElement('canvas');
          await renderPolaroid(highQualityCanvas, exportScale);
          const highQuality = canvasToDataURL(highQualityCanvas, EXPORT_QUALITY);
          
          // Create small thumbnail for cart display (1x scale, JPEG 0.85 quality)
          const thumbnailCanvas=document.createElement('canvas');
          await renderPolaroid(thumbnailCanvas, 1);
          const thumbnail = thumbnailCanvas.toDataURL('image/jpeg', 0.85);
          
          return { highQuality, thumbnail };
        }catch(e){ return { highQuality: '', thumbnail: '' }; }
      }

      function renderCart(){
        if(!cartItemsList) return;

        cartItems = cartItems.map(item => {
          const isPoster = /poster/i.test(item.title || '');
          const isPolaroid = /polaroid/i.test(item.title || '');

          if (isPoster) {
            item.price = PRICES.poster[currencyCode] || PRICES.poster.eur;
          } else if (isPolaroid) {
            item.price = PRICES.polaroid[currencyCode] || PRICES.polaroid.eur;
          }

          return item;
        });

        saveCartItems();

        cartItemsList.innerHTML = cartItems.map((item,i)=>{
          const isPoster=/poster/i.test(item.title||'');
          const useSrc = item.snapshot || item.img || '';

          return `
            <div class="cart-item${isPoster ? ' poster-item' : ''}">
              <button class="cart-del-btn" data-index="${i}" aria-label="delete">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                  <path d="M3 6h18" />
                  <path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />
                  <path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6" />
                  <path d="M10 11v6" />
                  <path d="M14 11v6" />
                </svg>
              </button>
              <img class="cart-polaroid-img" src="${useSrc}" alt="cart item" style="${useSrc ? '' : 'display:none'}">
              <div class="cart-price">${item.price}</div>
            </div>
          `;
        }).join('');

        updateCartTotalButton();
      }

      function computeCartTotal(){
        let sum=0;
        cartItems.forEach(it=>{
          const num=parseFloat(String(it.price).replace(/[^\d.]/g,''));
          // Guard against NaN: skip invalid prices (don't add to sum)
          if(Number.isFinite(num)) sum+=num;
        });
        // Guard against NaN delivery fee: use 0 if not finite
        const deliveryFee = currentDeliveryFeeNumber();
        sum += Number.isFinite(deliveryFee) ? deliveryFee : 0;
        return sum;
      }
      function updateCartTotalButton(){
        if(!storeCartTotalBtn) return;
        const total=computeCartTotal();
        const symbolPrice=PRICES.delivery[currencyCode]||PRICES.delivery.eur;
        const prefix=symbolPrice.replace(/[\d.,].*$/,'');
        storeCartTotalBtn.textContent='total ' + prefix + total.toFixed(2);
      }

      async function addCurrentPolaroidToCart(){
        const price=PRICES.polaroid[currencyCode]||PRICES.polaroid.eur;
        const storePolaroidImg=document.getElementById('storePolaroidImg');
        const storePolaroidSummary=document.getElementById('storePolaroidSummary');
        const storePolaroidTitle=document.getElementById('storePolaroidTitle');
        const img=storePolaroidImg && storePolaroidImg.src ? storePolaroidImg.src : '';
        const summary=storePolaroidSummary && storePolaroidSummary.textContent ? storePolaroidSummary.textContent : '';
        const title=storePolaroidTitle && storePolaroidTitle.textContent ? storePolaroidTitle.textContent : 'daily polaroid';
        const { highQuality, thumbnail } = await buildStorePolaroidSnapshot();
        // snapshot: thumbnail for cart display, snapshotDataUrl: high-quality for backend upload
        cartItems.push({ price, img, snapshot: thumbnail, snapshotDataUrl: highQuality, summary, title, hasSummary:true, soloPhoto:false, ts:Date.now() });
        saveCartItems();
        toastEl.classList.add('centered');
        showToast('added to cart');
        setTimeout(()=>toastEl.classList.remove('centered'),1700);
        updateCartTotalButton();
      }

      async function addCurrentPosterToCart(){
        const price=PRICES.poster[currencyCode]||PRICES.poster.eur;
        const snapshot = await buildStorePosterSnapshot();
        const storePosterTitle=document.getElementById('storePosterTitle');
        cartItems.push({ price, img:snapshot, snapshot, snapshotDataUrl:snapshot, summary:'', title:storePosterTitle.textContent||'monthly poster', hasSummary:false, soloPhoto:false, ts:Date.now() });
        saveCartItems();
        toastEl.classList.add('centered');
        showToast('added to cart');
        setTimeout(()=>toastEl.classList.remove('centered'),1700);
        updateCartTotalButton();
      }

      function getCSS(varName){
        return getComputedStyle(document.documentElement).getPropertyValue(varName).trim() || '#ffffff';
      }

      function rr(ctx,x,y,w,h,r){
        const radius=Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x+radius,y);
        ctx.arcTo(x+w,y,x+w,y+h,radius);
        ctx.arcTo(x+w,y+h,x,y+h,radius);
        ctx.arcTo(x,y+h,x,y,radius);
        ctx.arcTo(x,y,x+w,y,radius);
        ctx.closePath();
      }

      async function buildStorePosterSnapshot(){
        try{
          const square=document.querySelector('#storePosterImgWrap .poster-square');
          if(!square) return '';
          
          // Use high-quality export scale
          const exportScale = EXPORT_SCALE_MULTIPLIER;
          const rect=square.getBoundingClientRect();
          const size=Math.round(rect.width);
          const canvas=document.createElement('canvas');
          canvas.width=size*exportScale;
          canvas.height=size*exportScale;
          const ctx=canvas.getContext('2d', { alpha: false });
          ctx.scale(exportScale, exportScale);

          const topbarH=parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--topbar-h'))||64;
          const bodyH=window.innerHeight||size;
          const topPct=Math.min(100,(topbarH+1)/bodyH*100);
          const grad=ctx.createLinearGradient(0,0,0,size);
          grad.addColorStop(0,getCSS('--bg1'));
          grad.addColorStop(topPct/100,getCSS('--bg1'));
          grad.addColorStop(0.55,getCSS('--bg2'));
          grad.addColorStop(1,getCSS('--bg3'));
          ctx.fillStyle=grad;
          ctx.fillRect(0,0,size,size);

          const overlay = square.querySelector('.poster-title-overlay');
          if(overlay){
            const oRect=overlay.getBoundingClientRect();
            const y = Math.round(oRect.top - rect.top);
            const xCenter = size/2;
            const family=getComputedStyle(overlay).fontFamily || getComputedStyle(document.body).fontFamily || 'Comfortaa,sans-serif';
            const fSize=getComputedStyle(overlay).fontSize || '20px';
            const weight=getComputedStyle(overlay).fontWeight || '800';
            ctx.fillStyle=getCSS('--text')||'#000';
            ctx.textAlign='center';
            ctx.textBaseline='top';
            ctx.font=`${weight} ${fSize} ${family}`;
            ctx.fillText(overlay.textContent||'', xCenter, y);
          }

          const cells=[...square.querySelectorAll('.grid > *')].filter(el=>!el.classList.contains('pad'));
          const imgPromises=[];
          const imgMap=new Map();
          cells.forEach(c=>{
            const img=c.querySelector('img');
            if(img && img.src && !imgMap.has(img.src)){
              imgPromises.push(new Promise((res)=>{ const im=new Image(); im.onload=()=>{ imgMap.set(img.src,im); res(); }; im.onerror=()=>res(); im.src=img.src; }));
            }
          });
          await Promise.all(imgPromises);

          cells.forEach(c=>{
            const cRect=c.getBoundingClientRect();
            const x = Math.round(cRect.left - rect.left);
            const y = Math.round(cRect.top - rect.top);
            const w = Math.round(cRect.width);
            const h = Math.round(cRect.height);
            if(w<=0 || h<=0) return;
            ctx.save();
            rr(ctx,x,y,w,h,10);
            ctx.fillStyle=getCSS('--surface') || '#ffffff';
            ctx.fill();

            const img=c.querySelector('img');
            if(img && img.src && imgMap.has(img.src)){
              const im=imgMap.get(img.src);
              const iw=im.naturalWidth||im.width;
              const ih=im.naturalHeight||im.height;
              if(iw && ih){
                const r=Math.max(w/iw, h/ih);
                const dw=iw*r, dh=ih*r;
                const dx=x - (dw - w)/2;
                const dy=y - (dh - h)/2;
                ctx.clip();
                ctx.imageSmoothingEnabled=true;
                ctx.imageSmoothingQuality='high';
                ctx.drawImage(im, dx, dy, dw, dh);
              }
            }else{
              const num=c.querySelector('.num')?.textContent||'';
              if(num){
                const family=getComputedStyle(document.body).fontFamily||'Comfortaa,sans-serif';
                ctx.fillStyle=getCSS('--text')||'#000';
                ctx.font='600 13px ' + family;
                ctx.textAlign='center'; ctx.textBaseline='middle';
                ctx.fillText(num, x + w/2, y + h/2);
              }
            }
            ctx.restore();
          });

          // Use helper function for optimal format export
          return canvasToDataURL(canvas, EXPORT_QUALITY);
        }catch(e){ return ''; }
      }

      // Initialize YEAR from localStorage if present, otherwise use device date
      let savedYear = tryGet(YEAR_KEY);
      let YEAR = savedYear ? clamp(parseInt(savedYear, 10), MIN_YEAR, MAX_YEAR) : clamp(new Date().getFullYear(), MIN_YEAR, MAX_YEAR);
      yearTitleEl.textContent=String(YEAR);

      let isEditMode=true;
      let hadSummary=false;
      let draftPhotoData=null;
      let draftPhotoObjectURL=null; // Object URL for preview (revoked after save)
      let currentTab='standard'; // Track active tab: 'standard' or 'notes'
      let lastSavedTab='standard'; // Track which tab was used for last save

      let selectedDateKey=null;
      let originalData={ note:'', icon:'', word:'', song:'', movie:'', show:'', notesText:'', notesIcon:'' };
      let editingData={ note:'', icon:'', word:'', song:'', movie:'', show:'', notesText:'', notesIcon:'' };

      let photoCache={};
      let emojiCache={};

      let capsMode = tryGet(CAPS_KEY) || 'standard';
      applyCapsMode(capsMode,false);

      const FONT_MAP={
        roboto: `"Roboto",system-ui,-apple-system,"Segoe UI",sans-serif`,
        poppins: `"Poppins",system-ui,-apple-system,"Segoe UI",sans-serif`,
        merriweather: `"Merriweather",Georgia,serif`,
        cookie: `"Cookie",cursive`,
        dancingscript: `"Dancing Script",cursive`,
        pacifico: `"Pacifico",cursive`,
        boogaloo: `"Boogaloo",cursive`,
        caveat: `"Caveat",cursive`,
        indieflower: `"Indie Flower",cursive`,
        jersey10: `"Jersey 10",cursive`
      };
      const ICON_STROKE_MAP={
        cookie:1.6,
        dancingscript:1.6,
        pacifico:1.6,
        boogaloo:1.6,
        caveat:1.6,
        indieflower:1.6,
        jersey10:1.6,
        default:2.2
      };
      let fontKey = tryGet(FONT_KEY) || 'roboto';
      applyFont(fontKey,false);

      const THEMES=['pastel','dark','light','galaxy','sunset','forest','underwater','rainbow','fire','earth'];
      let themeKey=tryGet(THEME_KEY) || 'galaxy';
      applyTheme(themeKey,false);

      function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
      function makeKey(y,m,d){ return `photo-${y}-${String(m).padStart(2,'0')}-${String(d).padStart(2,'0')}`; }
      function baseDateKey(k){ return (k||'').replace(/^photo-/,''); }
      function iconKey(photoKey){ return 'icon-' + baseDateKey(photoKey); }
      function isNotesMode(base){
        const notesText=(tryGet(`notesText-${base}`)||'').trim();
        const notesIcon=(tryGet(`notesIcon-${base}`)||'').trim();
        return !!(notesText || notesIcon);
      }
      function trySet(k,v){ try{ localStorage.setItem(k,v); return true; }catch(e){ showToast('storage full'); return false; } }
      function tryGet(k){ try{ return localStorage.getItem(k); }catch(e){ return null; } }
      function showToast(msg){
        toastEl.textContent=(msg||'').toLowerCase();
        toastEl.style.display='block';
        clearTimeout(showToast._t);
        showToast._t=setTimeout(()=>toastEl.style.display='none',1600);
      }
      function ordinalSuffix(n){
        const j=n%10,k=n%100;
        if(k>=11&&k<=13)return'th';
        if(j===1)return'st';
        if(j===2)return'nd';
        if(j===3)return'rd';
        return'th';
      }
      function sentenceCase(str){
        return str.replace(/(^\s*[a-zA-Z]|[.!?]\s*[a-zA-Z])/g,s=>s.toUpperCase());
      }
      function capitalizeWords(str){
        return (str||'').replace(/(^|[\s\-_\/])([a-z])/g,(m,p1,p2)=> p1 + p2.toUpperCase());
      }
      function transformForDisplay(value,type){
        if(!value) return '';
        if(capsMode==='none') return value.toLowerCase();
        if(capsMode==='all') return value.toUpperCase();
        if(type==='sentence') return sentenceCase(value);
        if(type==='word') return capitalizeWords(value);
        return value;
      }
      function formatFullDate(year,month,day){
        const dow=new Date(year,month-1,day).toLocaleDateString('en-GB',{weekday:'long'});
        const mn=new Date(year,month-1,day).toLocaleDateString('en-GB',{month:'long'});
        const suffix=ordinalSuffix(day);
        // Use non-breaking spaces throughout to prevent wrapping of the date line
        let txt=`${dow}\u00A0${day}${suffix}\u00A0${mn}\u00A0${year}`;
        if(capsMode==='none') txt=txt.toLowerCase();
        if(capsMode==='all') txt=txt.toUpperCase();
        return txt;
      }
      function getEstimatedDeliveryRange(){
        const today = new Date();
        const startDate = new Date(today.getTime());
        startDate.setDate(startDate.getDate() + 5);
        const endDate = new Date(today.getTime());
        endDate.setDate(endDate.getDate() + 10);
        
        const startDay = startDate.getDate();
        const startMonth = startDate.toLocaleDateString('en-GB', {month: 'long'});
        const endDay = endDate.getDate();
        const endMonth = endDate.toLocaleDateString('en-GB', {month: 'long'});
        
        const startSuffix = ordinalSuffix(startDay);
        const endSuffix = ordinalSuffix(endDay);
        
        let text = `estimated delivery: ${startDay}${startSuffix} ${startMonth} - ${endDay}${endSuffix} ${endMonth}`;
        
        if(capsMode === 'none') {
          return text.toLowerCase();
        } else if(capsMode === 'all') {
          return text.toUpperCase();
        } else {
          // Standard caps: capitalize "Estimated" and month names
          return `Estimated delivery: ${startDay}${startSuffix} ${startMonth} - ${endDay}${endSuffix} ${endMonth}`;
        }
      }
      function getDeleteMessage(){
        if(capsMode==='none') return DELETE_MSG_BASE.toLowerCase();
        if(capsMode==='all') return DELETE_MSG_BASE.toUpperCase();
        return sentenceCase(DELETE_MSG_BASE);
      }
      function getDeleteTitle(){
        if(capsMode==='none') return DELETE_TITLE_BASE.toLowerCase();
        if(capsMode==='all') return DELETE_TITLE_BASE.toUpperCase();
        return capitalizeWords(DELETE_TITLE_BASE);
      }
      function transformProductText(base){
        if(capsMode==='none') return base.toLowerCase();
        if(capsMode==='all') return base.toUpperCase();
        return base.charAt(0).toUpperCase() + base.slice(1);
      }
      function refreshDeleteMessage(){
        deleteDataMessage.textContent=getDeleteMessage();
        deleteDataTitle.textContent=getDeleteTitle();
      }
      function refreshProductDescriptions(){
        storePolaroidDescription.textContent=transformProductText(PRODUCT_DAY_BASE);
        storePosterDescription.textContent=transformProductText(PRODUCT_MONTH_BASE);
        positionStorePolaroidSummary();
      }

      function applyFont(key, refreshUI){
        if(!FONT_MAP[key]) key='roboto';
        document.documentElement.style.setProperty('--app-font', FONT_MAP[key]);
        const stroke = ICON_STROKE_MAP[key] || ICON_STROKE_MAP.default;
        document.documentElement.style.setProperty('--icon-stroke', stroke);
        fontKey=key;
        trySet(FONT_KEY,key);
        if(refreshUI){
          fontsChoices.forEach(btn=>btn.classList.toggle('selected', btn.dataset.font===fontKey));
          if(selectedDateKey && dayModal.style.display==='flex' && !isEditMode){
            refreshSummaryFromStorage();
          }
          refreshProductDescriptions();
        }
      }

      function applyTheme(key, refreshUI){
        if(!THEMES.includes(key)) key='galaxy';
        document.documentElement.setAttribute('data-theme', key);
        themeKey=key;
        trySet(THEME_KEY,key);
        if(refreshUI){
          themeChoices.forEach(btn=>btn.classList.toggle('selected', btn.dataset.theme===themeKey));
          if(selectedDateKey && dayModal.style.display==='flex'){
            if(isEditMode) loadFieldsIntoEditUI(); else refreshSummaryFromStorage();
          }
          refreshProductDescriptions();
        }
      }

      function updateCurrencyUI(){
        storePolaroidBuyBtn.textContent=PRICES.polaroid[currencyCode]||PRICES.polaroid.eur;
        storePosterBuyBtn.textContent=PRICES.poster[currencyCode]||PRICES.poster.eur;
        deliveryFeePrice.textContent=PRICES.delivery[currencyCode]||PRICES.delivery.eur;
        updateCartTotalButton();
      }

      function openExternal(url){
        try{
          const win = window.open(url, '_blank', 'noopener,noreferrer');
          if(win){ win.opener = null; return; }
        }catch(e){}
        window.location.href = url;
      }

      function recalcCartPrices(){
        cartItems = cartItems.map(item => {
          const title = (item.title || "").toLowerCase();

          if (title.includes("poster")) {
            item.price = PRICES.poster[currencyCode] || PRICES.poster.eur;
          } else if (title.includes("polaroid")) {
            item.price = PRICES.polaroid[currencyCode] || PRICES.polaroid.eur;
          }

          return item;
        });

        saveCartItems();
      }

      function setCurrency(code){
        if(!PRICES.polaroid[code]) return;
        currencyCode=code;
        trySet(CURRENCY_KEY, code);
        currencyChoices.forEach(c=>c.classList.toggle('selected', c.dataset.currency===currencyCode));
        updateCurrencyUI();
        recalcCartPrices();
        renderCart();
      }

      function setTopbarHeight(){
        const h=topbarEl.offsetHeight||64;
        document.documentElement.style.setProperty('--topbar-h', h+'px');
      }
      window.addEventListener('load', setTopbarHeight);
      window.addEventListener('resize', setTopbarHeight);
      window.addEventListener('orientationchange', setTopbarHeight);
      setTimeout(setTopbarHeight,150);

      // Initialize calendar - wrapped in try-catch for startup robustness
      try {
        preloadYearAssets(YEAR);
        buildYear(YEAR);
      } catch (error) {
        console.error('Calendar initialization error (non-fatal):', error);
        // App continues running even if calendar build fails
      }
      
      // Background migration: Move localStorage photos to IndexedDB with thumbnails
      (async function migrateExistingPhotos(){
        try{
          const migrationPromises = [];
          const keysToMigrate = [];
          
          // Collect all photo keys from localStorage
          for(let i=0; i<localStorage.length; i++){
            const key = localStorage.key(i);
            if(!key || !key.startsWith('photo-')) continue;
            keysToMigrate.push(key);
          }
          
          if(keysToMigrate.length === 0){
            console.info('[Migration] No photos to migrate');
            return;
          }
          
          console.info(`[Migration] Starting migration of ${keysToMigrate.length} photos to IndexedDB...`);
          
          for(const key of keysToMigrate){
            try{
              const dataUrl = localStorage.getItem(key);
              if(!dataUrl || !dataUrl.startsWith('data:')) continue;
              
              // Migrate all data URLs to IndexedDB (non-blocking)
              const migrationTask = (async () => {
                try{
                  // Convert to Blob
                  const blob = dataUrlToBlob(dataUrl);
                  
                  // Compress to full resolution (max 1600px @ 0.82)
                  const fullBlob = await compressToFull(blob);
                  
                  // Compress to thumbnail (max 512px @ 0.70)
                  const thumbnailBlob = await compressToThumbnail(blob);
                  
                  // Store full-resolution Blob to IndexedDB
                  await idbPutPhoto(key, fullBlob);
                  
                  // Store thumbnail Blob to IndexedDB
                  await idbPutThumbnail(key, thumbnailBlob);
                  
                  // Remove image data from localStorage (keep only metadata)
                  localStorage.removeItem(key);
                  
                  // Update cache with thumbnail object URL
                  if(photoObjectURLCache[key]){
                    URL.revokeObjectURL(photoObjectURLCache[key]);
                  }
                  const thumbObjectURL = URL.createObjectURL(thumbnailBlob);
                  photoCache[key] = thumbObjectURL;
                  photoObjectURLCache[key] = thumbObjectURL;
                  
                  // Update calendar grid cell if visible
                  const cell = calPhoto.querySelector(`.day[data-date="${key}"]`);
                  if(cell){
                    const img = cell.querySelector('img');
                    if(img){
                      img.src = thumbObjectURL;
                      img.style.display = 'block';
                    }
                    cell.classList.add('has-photo');
                  }
                }catch(err){
                  console.warn('[Migration] Failed for', key, err);
                }
              })();
              
              migrationPromises.push(migrationTask);
            }catch(err){
              console.warn('[Migration] Error checking photo:', key, err);
            }
          }
          
          // Wait for all migrations to complete in background
          if(migrationPromises.length > 0){
            await Promise.all(migrationPromises);
            console.info(`[Migration] Complete - migrated ${migrationPromises.length} photos`);
          }
        }catch(err){
          console.error('[Migration] Error (non-fatal):', err);
        }
      })();

      function preloadYearAssets(year){
        photoCache={}; emojiCache={};
        for(let i=0;i<localStorage.length;i++){
          const k=localStorage.key(i);
          if(!k) continue;
          if(k.startsWith('photo-'+year+'-')){
            const v=tryGet(k); if(v) photoCache[k]=v;
          }else if(k.startsWith('icon-'+year+'-')){
            const v=tryGet(k); if(v){ const dayKey='photo-'+k.replace(/^icon-/,''); emojiCache[dayKey]=v; }
          }
        }
        Object.values(photoCache).forEach(src=>{
          const im=new Image(); im.decoding='sync'; im.loading='eager'; im.src=src;
        });
      }

      /**
       * Get photo for calendar grid - returns thumbnail from IndexedDB as object URL
       * Falls back to localStorage for legacy data
       * @param {string} key - Photo key
       * @returns {string|null} - Object URL or data URL
       */
      function getSavedPhoto(key){
        // Return cached object URL if available
        if(photoCache[key]) return photoCache[key];
        
        // Check localStorage for legacy data URL (will be migrated in background)
        let v=tryGet(key);
        if(v){ 
          photoCache[key]=v; 
          return v; 
        }
        
        // Try alternate key format
        const m=key.match(/^photo-(\d{4})-(\d{2})-(\d{2})$/);
        if(m){
          const alt=`photo-${m[1]}-${Number(m[2])}-${Number(m[3])}`;
          v=tryGet(alt);
          if(v){ 
            photoCache[key]=v; 
            return v; 
          }
        }
        
        return null;
      }
      
      /**
       * Async version of getSavedPhoto that loads thumbnail from IndexedDB
       * Used by calendar grid to display thumbnails
       * @param {string} key - Photo key
       * @returns {Promise<string|null>} - Object URL or data URL
       */
      async function getSavedPhotoThumbnail(key){
        // Return cached value if available
        if(photoCache[key]) return photoCache[key];
        
        try{
          // Try IndexedDB thumbnail first
          const thumbBlob = await idbGetThumbnail(key);
          if(thumbBlob){
            // Revoke old object URL if exists
            if(photoObjectURLCache[key]){
              URL.revokeObjectURL(photoObjectURLCache[key]);
            }
            // Create new object URL
            const objectUrl = URL.createObjectURL(thumbBlob);
            photoCache[key] = objectUrl;
            photoObjectURLCache[key] = objectUrl;
            return objectUrl;
          }
        }catch(err){
          console.error('Error loading thumbnail from IndexedDB:', err);
        }
        
        // Fallback to localStorage or sync getSavedPhoto
        return getSavedPhoto(key);
      }
      
      /**
       * Get photo for day view - tries IndexedDB first (full resolution), then falls back to thumbnail
       * @param {string} key - Photo key
       * @param {boolean} preferFullResolution - If true, try IndexedDB first for full resolution
       * @returns {Promise<string|null>} - Object URL or data URL
       */
      async function getSavedPhotoForDayView(key, preferFullResolution = true){
        if(preferFullResolution){
          try{
            // Try IndexedDB first for full resolution
            const blob = await idbGetPhoto(key);
            if(blob){
              // Revoke old object URL if exists
              if(photoObjectURLCache[key]){
                URL.revokeObjectURL(photoObjectURLCache[key]);
              }
              // Create new object URL
              const objectUrl = URL.createObjectURL(blob);
              photoObjectURLCache[key] = objectUrl;
              return objectUrl;
            }
          }catch(err){
            console.error('Error loading photo from IndexedDB:', err);
          }
        }
        
        // Fallback to thumbnail
        return await getSavedPhotoThumbnail(key);
      }

      function monthName(year,monthIndex){
        const raw=new Date(year,monthIndex,1).toLocaleDateString('en-GB',{month:'long'});
        if(capsMode==='none') return raw.toLowerCase();
        if(capsMode==='all') return raw.toUpperCase();
        return raw;
      }

      function buildYear(year){
        calPhoto.innerHTML='';
        calEmoji.innerHTML='';
        buildPhotoCalendar(year);
        buildEmojiCalendar(year);
        setupInfiniteCarousel();
      }

      function buildPhotoCalendar(year){
        for(let m=0;m<12;m++){
          const section=document.createElement('section');
          section.className='month';
          const h2=document.createElement('h2');
          h2.textContent=monthName(year,m);
          section.appendChild(h2);
          const grid=document.createElement('div'); grid.className='grid'; section.appendChild(grid);
          const first=new Date(year,m,1);
          const days=new Date(year,m+1,0).getDate();
          const mondayIndex=(first.getDay()+6)%7;
          for(let i=0;i<mondayIndex;i++){ const pad=document.createElement('div'); pad.className='pad'; grid.appendChild(pad); }
          for(let d=1;d<=days;d++){
            const key=makeKey(year,m+1,d);
            const cell=document.createElement('div');
            cell.className='day';
            cell.dataset.date=key; cell.dataset.y=year; cell.dataset.m=m+1; cell.dataset.d=d;
            const num=document.createElement('div'); num.className='num'; num.textContent=d; cell.appendChild(num);
            const img=document.createElement('img'); img.alt=`${h2.textContent} ${d} photo`; img.loading='eager'; img.decoding='sync'; cell.appendChild(img);
            
            // Try to load synchronously from cache first
            const saved=getSavedPhoto(key);
            if(saved){ 
              img.src=saved; 
              img.style.display='block'; 
              cell.classList.add('has-photo'); 
            } else {
              // Load thumbnail from IndexedDB asynchronously
              loadThumbnailForCell(key, img, cell);
            }
            
            grid.appendChild(cell);
          }
          const tail=grid.children.length%7;
          if(tail!==0){ for(let i=0;i<7-tail;i++){ const pad=document.createElement('div'); pad.className='pad'; grid.appendChild(pad); } }
          calPhoto.appendChild(section);
        }
      }
      
      /**
       * Async helper to load thumbnail for a calendar cell
       * @param {string} key - Photo key
       * @param {HTMLImageElement} img - Image element
       * @param {HTMLElement} cell - Cell element
       */
      async function loadThumbnailForCell(key, img, cell){
        try{
          const thumbUrl = await getSavedPhotoThumbnail(key);
          if(thumbUrl){
            img.src=thumbUrl;
            img.style.display='block';
            cell.classList.add('has-photo');
          }
        }catch(err){
          console.error('Error loading thumbnail for cell:', key, err);
        }
      }

      function buildEmojiCalendar(year){
        for(let m=0;m<12;m++){
          const section=document.createElement('section');
          section.className='month';
          const h2=document.createElement('h2');
          h2.textContent=monthName(year,m);
          section.appendChild(h2);
          const grid=document.createElement('div'); grid.className='grid'; section.appendChild(grid);
          const first=new Date(year,m,1);
          const days=new Date(year,m+1,0).getDate();
          const mondayIndex=(first.getDay()+6)%7;
          for(let i=0;i<mondayIndex;i++){ const pad=document.createElement('div'); pad.className='pad'; grid.appendChild(pad); }
          for(let d=1;d<=days;d++){
            const photoKey=makeKey(year,m+1,d);
            const base=baseDateKey(photoKey);
            
            // For notes-mode: NO emoji badge on the day-view polaroid
            // For standard-mode: show emoji badge if icon exists
            let iconVal = '';
            if (!isNotesMode(base)) {
              iconVal = emojiCache[photoKey] || tryGet(iconKey(photoKey)) || '';
            }
            
            const cell=document.createElement('div');
            cell.className='day emoji-day';
            cell.dataset.date=photoKey; cell.dataset.y=year; cell.dataset.m=m+1; cell.dataset.d=d;
            const num=document.createElement('div'); num.className='num'; num.textContent=d; cell.appendChild(num);
            if(iconVal){
              const em=document.createElement('div'); em.className='emoji-badge'; em.textContent=iconVal;
              cell.appendChild(em); cell.classList.add('has-emoji');
            }
            grid.appendChild(cell);
          }
          const tail=grid.children.length%7;
          if(tail!==0){ for(let i=0;i<7-tail;i++){ const pad=document.createElement('div'); pad.className='pad'; grid.appendChild(pad); } }
          calEmoji.appendChild(section);
        }
      }

      function updateEmojiCell(photoKey){
        const cell=calEmoji.querySelector(`.day[data-date="${photoKey}"]`);
        if(!cell) return;
        const base=baseDateKey(photoKey);
        
        // Get the appropriate emoji depending on mode
        let iconVal = '';
        if (isNotesMode(base)) {
          // Notes mode: use notesIcon for emoji calendar
          iconVal = (tryGet(`notesIcon-${base}`)||'').trim();
        } else {
          // Standard mode: use icon for emoji calendar
          iconVal = (tryGet(`icon-${base}`)||'').trim();
        }
        
        let badge=cell.querySelector('.emoji-badge');
        if(iconVal){
          if(!badge){ badge=document.createElement('div'); badge.className='emoji-badge'; cell.appendChild(badge); }
          badge.textContent=iconVal; cell.classList.add('has-emoji');
        }else{
          if(badge) badge.remove();
          cell.classList.remove('has-emoji');
        }
      }

      document.getElementById('app').addEventListener('click',(e)=>{
        const cell=e.target.closest('.day');
        if(!cell) return;
        const y=Number(cell.dataset.y);
        const m=Number(cell.dataset.m);
        const d=Number(cell.dataset.d);
        const key=cell.dataset.date;
        openDay(y,m-1,d,key);
      });

      function openDay(year,monthIdx,d,key){
        selectedDateKey=key;
        draftPhotoData=null;
        setDayTitle(year,monthIdx,d);
        loadPhoto(true);
        captureOriginalData();
        loadFieldsIntoEditUI();
        hadSummary=hasExistingSummary();
        if(hadSummary) enterSummaryMode(); else exitSummaryMode();
        lockBodyScroll();
        yearBackdrop.style.display='none';
        yearModal.style.display='none';
        dayBackdrop.style.display='block';
        dayModal.style.display='flex';
        resetScreenScroll(dayModal);
        setTimeout(()=>{ if(!bigPreviewImg.src) loadPhoto(true); },100);
      }

      function setDayTitle(year,monthIdx,dayNum){
        const dow=new Date(year,monthIdx,dayNum).toLocaleDateString('en-GB',{weekday:'long'});
        const mn=monthName(year,monthIdx);
        const suffix=ordinalSuffix(dayNum);
        let txt=`${dow} ${dayNum}${suffix} ${mn} ${year}`;
        if(capsMode==='none') txt=txt.toLowerCase();
        if(capsMode==='all') txt=txt.toUpperCase();
        dayTitleText.textContent=txt;
      }

      function captureOriginalData(){
        if(!selectedDateKey) return;
        const base=baseDateKey(selectedDateKey);
        originalData={
          note:(tryGet(`note-${base}`)||''),
          icon:(tryGet(`icon-${base}`)||''),
          word:(tryGet(`word-${base}`)||''),
          song:(tryGet(`song-${base}`)||''),
          movie:(tryGet(`movie-${base}`)||''),
          show:(tryGet(`show-${base}`)||''),
          notesText:(tryGet(`notesText-${base}`)||''),
          notesIcon:(tryGet(`notesIcon-${base}`)||'')
        };
        editingData={...originalData};
        // Determine last saved tab
        lastSavedTab = (originalData.notesText || originalData.notesIcon) ? 'notes' : 'standard';
      }

      function loadFieldsIntoEditUI(){
        // Standard tab fields
        photoNotes.value=editingData.note||'';
        emojiGrid.querySelectorAll('.emoji-chip.selected').forEach(c=>c.classList.remove('selected'));
        if(editingData.icon){
          const chip=emojiGrid.querySelector(`.emoji-chip[data-emoji="${editingData.icon}"]`);
          if(chip){ chip.classList.add('selected'); }
          else if(customEmojiInput){
            customEmojiInput.value=editingData.icon;
            customEmojiChip.classList.add('selected');
          }
        }
        wordGrid.querySelectorAll('.word-chip.selected').forEach(c=>c.classList.remove('selected'));
        customWordInput.value=''; document.getElementById('customWordChip').classList.remove('selected');
        if(editingData.word){
          const w=editingData.word;
          const chip=wordGrid.querySelector(`.word-chip[data-word="${w}"]`);
          if(chip){ chip.classList.add('selected'); }
          else { customWordInput.value=transformForDisplay(w,'word'); document.getElementById('customWordChip').classList.add('selected'); }
        }
        songInput.value=transformForDisplay(editingData.song,'text');
        movieInput.value=transformForDisplay(editingData.movie,'text');
        showInput.value=transformForDisplay(editingData.show,'text');
        
        // Notes tab fields
        if(photoNotesNotes) photoNotesNotes.value=editingData.notesText||'';
        if(emojiGridNotes) emojiGridNotes.querySelectorAll('.emoji-chip.selected').forEach(c=>c.classList.remove('selected'));
        if(customEmojiChipNotes) customEmojiChipNotes.classList.remove('selected');
        if(editingData.notesIcon){
          const chip=emojiGridNotes.querySelector(`.emoji-chip[data-emoji="${editingData.notesIcon}"]`);
          if(chip){ chip.classList.add('selected'); }
          else if(customEmojiInputNotes){
            customEmojiInputNotes.value=editingData.notesIcon;
            customEmojiChipNotes.classList.add('selected');
          }
        }
      }

      function hasSavedPhoto(){ return !!getSavedPhoto(selectedDateKey); }
      function hasExistingSummary(){
        if(!selectedDateKey) return false;
        if(hasSavedPhoto()) return true;
        const base=baseDateKey(selectedDateKey);
        return ['note-','icon-','word-','song-','movie-','show-','notesText-','notesIcon-'].some(p=> (tryGet(p+base)||'').trim().length);
      }

      async function loadPhoto(fallback){
        // First check if we have a draft photo
        if(draftPhotoData || draftPhotoObjectURL){
          applyPhoto(draftPhotoObjectURL || draftPhotoData);
          return;
        }
        
        // Try to load from IndexedDB (full resolution) for day view
        const fullResPhoto = await getSavedPhotoForDayView(selectedDateKey, true);
        if(fullResPhoto){
          applyPhoto(fullResPhoto);
          return;
        }
        
        // Fallback to calendar cell if requested
        if(fallback){
          const cellImg=document.querySelector(`#calPhoto .day[data-date="${selectedDateKey}"] img`);
          if(cellImg && cellImg.src){
            applyPhoto(cellImg.src);
            return;
          }
        }
        
        // No photo found
        applyPhoto(null);
      }
      
      function applyPhoto(src){
        if(src){
          bigPreviewImg.src=src;
          bigPreviewImg.style.display='block';
          bigPreviewPlaceholder.style.display='none';
          bigPreviewImg.decode?.().catch(()=>{});
        }else{
          bigPreviewImg.src='';
          bigPreviewImg.style.display='none';
          if(isEditMode){
            bigPreviewPlaceholder.style.display='grid';
          }else{
            bigPreviewPlaceholder.style.display='none';
          }
        }
      }

      // Standard tab note input handler - supports 2 lines, 40 chars per line
      photoNotes.addEventListener('input',()=>{
        if(!isEditMode) return;
        let v=photoNotes.value;
        // Handle line wrapping: max 2 lines, 40 chars per line
        const lines = v.split('\n');
        let processedLines = [];
        for(let line of lines){
          // Break line into chunks of 40 chars
          while(line.length > 40){
            processedLines.push(line.substring(0, 40));
            line = line.substring(40);
          }
          if(line.length > 0 || processedLines.length < 2) processedLines.push(line);
          if(processedLines.length >= 2) break;
        }
        // Limit to 2 lines
        processedLines = processedLines.slice(0, 2);
        const newValue = processedLines.join('\n');
        if(newValue !== v){
          photoNotes.value = newValue;
        }
        editingData.note = newValue;
      });

      emojiGrid.addEventListener('click',(e)=>{
        if(!isEditMode) return;
        const chip=e.target.closest('.emoji-chip'); if(!chip) return;
        if(chip.classList.contains('selected')){
          chip.classList.remove('selected');
          editingData.icon='';
        }else{
          emojiGrid.querySelectorAll('.emoji-chip.selected').forEach(c=>c.classList.remove('selected'));
          document.getElementById('customEmojiChip').classList.remove('selected');
          chip.classList.add('selected');
          editingData.icon=chip.dataset.emoji;
          customEmojiInput.value='';
        }
      });

      document.getElementById('customEmojiChip').addEventListener('click',()=>{
        if(!isEditMode) return;
        emojiGrid.querySelectorAll('.emoji-chip.selected').forEach(c=>c.classList.remove('selected'));
        document.getElementById('customEmojiChip').classList.add('selected');
        customEmojiInput.focus();
      });
      customEmojiInput.addEventListener('input',()=>{
        if(!isEditMode) return;
        const seg = (typeof Intl!=='undefined' && Intl.Segmenter)? new Intl.Segmenter(undefined,{granularity:'grapheme'}):null;
        let raw=(customEmojiInput.value||'').trim();
        let g=raw;
        if(seg){
          for(const part of seg.segment(raw)){ g=part.segment; break; }
        }else{
          g=Array.from(raw)[0]||'';
        }
        if(customEmojiInput.value!==g) customEmojiInput.value=g;
        if(g){
          emojiGrid.querySelectorAll('.emoji-chip.selected').forEach(c=>c.classList.remove('selected'));
          document.getElementById('customEmojiChip').classList.add('selected');
          editingData.icon=g;
        }else{
          document.getElementById('customEmojiChip').classList.remove('selected');
          editingData.icon='';
        }
      });

      wordGrid.addEventListener('click',(e)=>{
        if(!isEditMode) return;
        const chip=e.target.closest('.word-chip'); if(!chip) return;
        if(chip.classList.contains('selected')){
          chip.classList.remove('selected');
          editingData.word='';
        }else{
          wordGrid.querySelectorAll('.word-chip.selected').forEach(c=>c.classList.remove('selected'));
          document.getElementById('customWordChip').classList.remove('selected'); customWordInput.value='';
          chip.classList.add('selected');
          editingData.word=chip.dataset.word.toLowerCase();
        }
      });
      document.getElementById('customWordChip').addEventListener('click',()=>{
        if(!isEditMode) return;
        if(document.getElementById('customWordChip').classList.contains('selected') && !customWordInput.value.trim()){
          document.getElementById('customWordChip').classList.remove('selected');
          editingData.word='';
        }else{
          wordGrid.querySelectorAll('.word-chip.selected').forEach(c=>c.classList.remove('selected'));
          document.getElementById('customWordChip').classList.add('selected');
          customWordInput.focus();
        }
      });
      customWordInput.addEventListener('input',()=>{
        if(!isEditMode) return;
        let v=customWordInput.value.replace(/\n/g,' ');
        if(capsMode==='none') v=v.toLowerCase();
        else if(capsMode==='all') v=v.toUpperCase();
        customWordInput.value=v;
        if(v.trim()){
          wordGrid.querySelectorAll('.word-chip.selected').forEach(c=>c.classList.remove('selected'));
          document.getElementById('customWordChip').classList.add('selected');
          editingData.word=v.trim().toLowerCase();
        }else{
          document.getElementById('customWordChip').classList.remove('selected');
          editingData.word='';
        }
      });

      function transformSimpleFieldInput(el){
        if(!isEditMode) return;
        let v=el.value.replace(/\n/g,' ');
        if(capsMode==='none') v=v.toLowerCase();
        else if(capsMode==='all') v=v.toUpperCase();
        el.value=v;
      }
      songInput.addEventListener('input',()=>{ transformSimpleFieldInput(songInput); editingData.song=songInput.value; });
      movieInput.addEventListener('input',()=>{ transformSimpleFieldInput(movieInput); editingData.movie=movieInput.value; });
      showInput.addEventListener('input',()=>{ transformSimpleFieldInput(showInput); editingData.show=showInput.value; });

      // Tab switching
      if(standardTabBtn) standardTabBtn.addEventListener('click', ()=>{ switchToTab('standard'); });
      if(notesTabBtn) notesTabBtn.addEventListener('click', ()=>{ switchToTab('notes'); });

      // Notes tab input handlers
      if(photoNotesNotes){
        photoNotesNotes.addEventListener('input',()=>{
          if(!isEditMode) return;
          let v=photoNotesNotes.value;
          // Handle line wrapping: max 7 lines, 40 chars per line
          const lines = v.split('\n');
          let processedLines = [];
          for(let line of lines){
            // Break line into chunks of 40 chars
            while(line.length > 40){
              processedLines.push(line.substring(0, 40));
              line = line.substring(40);
            }
            if(line.length > 0 || processedLines.length < 7) processedLines.push(line);
            if(processedLines.length >= 7) break;
          }
          // Limit to 7 lines
          processedLines = processedLines.slice(0, 7);
          const newValue = processedLines.join('\n');
          if(newValue !== v){
            photoNotesNotes.value = newValue;
          }
          editingData.notesText = newValue;
        });
      }

      if(emojiGridNotes){
        emojiGridNotes.addEventListener('click',(e)=>{
          if(!isEditMode) return;
          const chip=e.target.closest('.emoji-chip'); if(!chip) return;
          if(chip.classList.contains('selected')){
            chip.classList.remove('selected');
            editingData.notesIcon='';
          }else{
            emojiGridNotes.querySelectorAll('.emoji-chip.selected').forEach(c=>c.classList.remove('selected'));
            if(customEmojiChipNotes) customEmojiChipNotes.classList.remove('selected');
            chip.classList.add('selected');
            editingData.notesIcon=chip.dataset.emoji;
            if(customEmojiInputNotes) customEmojiInputNotes.value='';
          }
        });
      }

      if(customEmojiChipNotes){
        customEmojiChipNotes.addEventListener('click',()=>{
          if(!isEditMode) return;
          if(emojiGridNotes) emojiGridNotes.querySelectorAll('.emoji-chip.selected').forEach(c=>c.classList.remove('selected'));
          customEmojiChipNotes.classList.add('selected');
          if(customEmojiInputNotes) customEmojiInputNotes.focus();
        });
      }

      if(customEmojiInputNotes){
        customEmojiInputNotes.addEventListener('input',()=>{
          if(!isEditMode) return;
          const seg = (typeof Intl!=='undefined' && Intl.Segmenter)? new Intl.Segmenter(undefined,{granularity:'grapheme'}):null;
          let raw=(customEmojiInputNotes.value||'').trim();
          let g=raw;
          if(seg){
            for(const part of seg.segment(raw)){ g=part.segment; break; }
          }else{
            g=Array.from(raw)[0]||'';
          }
          if(customEmojiInputNotes.value!==g) customEmojiInputNotes.value=g;
          if(g){
            if(emojiGridNotes) emojiGridNotes.querySelectorAll('.emoji-chip.selected').forEach(c=>c.classList.remove('selected'));
            customEmojiChipNotes.classList.add('selected');
            editingData.notesIcon=g;
          }else{
            customEmojiChipNotes.classList.remove('selected');
            editingData.notesIcon='';
          }
        });
      }

      saveDayBtn.addEventListener('click', async ()=>{
        if(!isEditMode || !selectedDateKey) return;
        saveDayBtn.disabled=true;
        const base=baseDateKey(selectedDateKey);
        
        // Handle photo persistence with IndexedDB for full + thumbnail
        let photoBlob = null;
        let photoToSave = draftPhotoData;
        
        // First, try to get Blob from draftPhotoObjectURL (if available from framing)
        if(draftPhotoObjectURL && draftPhotoObjectURL.startsWith('blob:')){
          try{
            const response = await fetch(draftPhotoObjectURL);
            photoBlob = await response.blob();
          }catch(err){
            console.error('Failed to fetch blob from object URL:', err);
          }
        }
        
        // If no blob yet and we have draftPhotoData, convert it to Blob
        if(!photoBlob && photoToSave){
          try{
            photoBlob = dataUrlToBlob(photoToSave);
          }catch(err){
            console.error('Failed to convert data URL to blob:', err);
          }
        }
        
        // If still no blob/photo and we have a preview image, create from canvas
        if(!photoBlob && !photoToSave && bigPreviewImg.src && bigPreviewImg.style.display !== 'none'){
          try{
            const S = bigPreviewImg.naturalWidth || bigPreviewImg.width;
            const exportScale = EXPORT_SCALE_MULTIPLIER;
            const exportSize = S * exportScale;
            
            const canvas = document.createElement('canvas');
            canvas.width = exportSize;
            canvas.height = exportSize;
            const ctx = canvas.getContext('2d', { alpha: false });
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(bigPreviewImg, 0, 0, exportSize, exportSize);
            
            photoBlob = await canvasToBlob(canvas, EXPORT_QUALITY);
          }catch(err){
            console.error('Failed to create blob from preview:', err);
            showToast('photo save failed');
          }
        }
        
        // Now persist the photo
        if(photoBlob){
          try{
            // 1. Compress to full resolution (max 1600px @ 0.82)
            const fullBlob = await compressToFull(photoBlob);
            
            // 2. Compress to thumbnail (max 512px @ 0.70)
            const thumbnailBlob = await compressToThumbnail(photoBlob);
            
            // 3. Store full-resolution Blob to IndexedDB
            await idbPutPhoto(selectedDateKey, fullBlob);
            
            // 4. Store thumbnail Blob to IndexedDB
            await idbPutThumbnail(selectedDateKey, thumbnailBlob);
            
            // 5. Remove photo data from localStorage (keep only metadata flag)
            localStorage.removeItem(selectedDateKey);
            
            // 6. Update photoCache with object URL from thumbnail for grid display
            if(photoObjectURLCache[selectedDateKey]){
              URL.revokeObjectURL(photoObjectURLCache[selectedDateKey]);
            }
            const thumbObjectURL = URL.createObjectURL(thumbnailBlob);
            photoCache[selectedDateKey] = thumbObjectURL;
            photoObjectURLCache[selectedDateKey] = thumbObjectURL;
            
            // 7. Update calendar grid with thumbnail
            const cell=calPhoto.querySelector(`.day[data-date="${selectedDateKey}"]`);
            if(cell){
              const img=cell.querySelector('img');
              if(img){ 
                img.src=thumbObjectURL; 
                img.style.display='block'; 
              }
              cell.classList.add('has-photo');
            }
          }catch(err){
            console.error('Failed to save photo:', err);
            showToast('photo save failed');
          }
          
          draftPhotoData=null;
          
          // Clean up object URL if it exists
          if(draftPhotoObjectURL){
            URL.revokeObjectURL(draftPhotoObjectURL);
            draftPhotoObjectURL=null;
          }
        }
        
        // Save based on current tab - only save active tab's content
        if(currentTab === 'standard'){
          // Save standard tab data
          trySet(`note-${base}`,editingData.note||'');
          trySet(`icon-${base}`,editingData.icon||'');
          trySet(`word-${base}`,editingData.word||'');
          trySet(`song-${base}`,editingData.song||'');
          trySet(`movie-${base}`,editingData.movie||'');
          trySet(`show-${base}`,editingData.show||'');
          // Clear notes tab data
          trySet(`notesText-${base}`,'');
          trySet(`notesIcon-${base}`,'');
        } else {
          // Save notes tab data (only text and icon)
          trySet(`notesText-${base}`,editingData.notesText||'');
          trySet(`notesIcon-${base}`,editingData.notesIcon||'');
          // Clear standard tab data
          trySet(`note-${base}`,'');
          trySet(`icon-${base}`,'');
          trySet(`word-${base}`,'');
          trySet(`song-${base}`,'');
          trySet(`movie-${base}`,'');
          trySet(`show-${base}`,'');
        }

        // Update emoji calendar - add emoji for both tabs
        updateEmojiCell(selectedDateKey);
        
        captureOriginalData();
        refreshSummaryFromStorage();
        hadSummary=hasExistingSummary();
        enterSummaryMode();
        showToast('saved');
        saveDayBtn.disabled=false;
        resetScreenScroll(dayModal);
      });

      editDayBtn.addEventListener('click',()=>{
        editingData={...originalData};
        exitSummaryMode();
        loadFieldsIntoEditUI();
        resetScreenScroll(dayModal);
      });

      backBtn.addEventListener('click',()=>{
        if(isEditMode){
          draftPhotoData=null;
          editingData={...originalData};
          loadFieldsIntoEditUI();
          if(hadSummary) enterSummaryMode(); else closeDayModal();
        }else closeDayModal();
        resetScreenScroll(document.body);
      });

      function refreshSummaryFromStorage(){
        if(!selectedDateKey) return;
        const base=baseDateKey(selectedDateKey)||'';
        const note=(tryGet(`note-${base}`)||'');
        const icon=(tryGet(`icon-${base}`)||'');
        const word=(tryGet(`word-${base}`)||'');
        const song=(tryGet(`song-${base}`)||'');
        const movie=(tryGet(`movie-${base}`)||'');
        const show=(tryGet(`show-${base}`)||'');
        const notesText=(tryGet(`notesText-${base}`)||'');
        const notesIcon=(tryGet(`notesIcon-${base}`)||'');
        
        const blocks=[];
        const m=selectedDateKey.match(/^photo-(\d{4})-(\d{2})-(\d{2})$/);
        if(m) blocks.push(formatFullDate(+m[1],+m[2],+m[3]));
        
        if(isNotesMode(base)){
          // Notes-mode rendering: show notes text (preserve line breaks), NO emoji
          if(notesText) blocks.push(notesText);
        } else {
          // Standard-mode rendering: show all six categories with emoji
          if(note) {
            blocks.push(note);
          }
          
          const meta=[];
          if(word) meta.push(transformForDisplay(word,'word'));
          if(icon) meta.push(icon);
          if(meta.length) blocks.push(meta.join('\n'));
          
          const media=[];
          if(song) media.push(`üé∂ ${transformForDisplay(song,'text')} üé∂`);
          if(movie) media.push(`üéü ${transformForDisplay(movie,'text')} üéü`);
          if(show) media.push(`üì∫ ${transformForDisplay(show,'text')} üì∫`);
          if(media.length) blocks.push(media.join('\n'));
        }
        
        polaroidSummary.textContent=blocks.join('\n');
        if(blocks.length){
          polaroid.classList.add('has-summary');
          polaroid.classList.remove('solo-photo');
        }else{
          polaroid.classList.remove('has-summary');
          if(hasSavedPhoto()) polaroid.classList.add('solo-photo'); else polaroid.classList.remove('solo-photo');
        }
        if(!isEditMode && !hasSavedPhoto()){
          bigPreviewPlaceholder.style.display='none';
        }
      }

      function enterSummaryMode(){
        isEditMode=false;
        polaroidImgWrap.classList.add('disabled');
        polaroid.classList.add('viewer-polaroid'); // Add viewer-only class for scoped styling
        if(editTabs) editTabs.style.display='none';
        if(editStandardPane) editStandardPane.style.display='none';
        if(editNotesPane) editNotesPane.style.display='none';
        refreshSummaryFromStorage();
        saveDayBtn.classList.add('hidden');
        editDayBtn.classList.remove('hidden');
        polaroidSummary.style.display=polaroid.classList.contains('has-summary')?'block':'none';
        bigPreviewPlaceholder.style.display='none';
        saveDayBtn.classList.remove('primary-btn');
        resetScreenScroll(dayModal);
      }

      function exitSummaryMode(){
        isEditMode=true;
        polaroidImgWrap.classList.remove('disabled');
        polaroid.classList.remove('viewer-polaroid'); // Remove viewer-only class
        saveDayBtn.classList.remove('hidden');
        editDayBtn.classList.add('hidden');
        polaroidSummary.style.display='none';
        polaroid.classList.remove('has-summary');
        if(getSavedPhoto(selectedDateKey)) {
          polaroid.classList.add('solo-photo');
          bigPreviewPlaceholder.style.display='none';
        } else {
          polaroid.classList.remove('solo-photo');
          bigPreviewPlaceholder.style.display='grid';
        }
        saveDayBtn.classList.add('primary-btn');
        
        // Show tabs and switch to default tab
        if(editTabs) editTabs.style.display='flex';
        switchToTab(lastSavedTab);
        
        resetScreenScroll(dayModal);
      }

      function switchToTab(tabName){
        currentTab = tabName;
        
        // Update tab button states
        if(standardTabBtn) standardTabBtn.classList.toggle('selected', tabName === 'standard');
        if(notesTabBtn) notesTabBtn.classList.toggle('selected', tabName === 'notes');
        
        // Show/hide panes using display instead of visibility to avoid layout shifts
        if(tabName === 'standard'){
          if(editStandardPane) editStandardPane.style.display='contents';
          if(editNotesPane) editNotesPane.style.display='none';
        } else {
          if(editStandardPane) editStandardPane.style.display='none';
          if(editNotesPane) editNotesPane.style.display='contents';
        }
      }

      settingsBtn.addEventListener('click', openSettingsFS);
      settingsFSBackdrop.addEventListener('click',(e)=>{ if(e.target===settingsFSBackdrop) closeSettingsFS(); });
      settingsBackBtn.addEventListener('click', closeSettingsFS);

      openCapsBtn.addEventListener('click', ()=>{
        settingsFSBackdrop.style.display='none'; settingsFS.style.display='none';
        capsFSBackdrop.style.display='block'; capsFS.style.display='flex'; refreshCapsSelectionUI(); resetScreenScroll(capsFS);
      });
      capsFSBackdrop.addEventListener('click',(e)=>{ if(e.target===capsFSBackdrop){ capsFS.style.display='none'; capsFSBackdrop.style.display='none'; openSettingsFS(); } });
      capsBackBtn.addEventListener('click',()=>{ capsFS.style.display='none'; capsFSBackdrop.style.display='none'; openSettingsFS(); });

      openFontsBtn.addEventListener('click', ()=>{
        settingsFSBackdrop.style.display='none'; settingsFS.style.display='none';
        fontsFSBackdrop.style.display='block'; fontsFS.style.display='flex'; fontsChoices.forEach(btn=>btn.classList.toggle('selected', btn.dataset.font===fontKey)); resetScreenScroll(fontsFS);
      });
      fontsFSBackdrop.addEventListener('click',(e)=>{ if(e.target===fontsFSBackdrop){ fontsFS.style.display='none'; fontsFSBackdrop.style.display='none'; openSettingsFS(); } });
      fontsBackBtn.addEventListener('click',()=>{ fontsFS.style.display='none'; fontsFSBackdrop.style.display='none'; openSettingsFS(); });

      openThemesBtn.addEventListener('click', ()=>{
        settingsFSBackdrop.style.display='none'; settingsFS.style.display='none';
        themesFSBackdrop.style.display='block'; themesFS.style.display='flex'; themeChoices.forEach(btn=>btn.classList.toggle('selected', btn.dataset.theme===themeKey)); resetScreenScroll(themesFS);
      });
      themesFSBackdrop.addEventListener('click',(e)=>{ if(e.target===themesFSBackdrop){ themesFS.style.display='none'; themesFSBackdrop.style.display='none'; openSettingsFS(); } });
      themesBackBtn.addEventListener('click',()=>{ themesFS.style.display='none'; themesFSBackdrop.style.display='none'; openSettingsFS(); });

      openCurrencyBtn.addEventListener('click', ()=>{
        settingsFSBackdrop.style.display='none'; settingsFS.style.display='none';
        currencyFSBackdrop.style.display='block'; currencyFS.style.display='flex';
        currencyChoices.forEach(c=>c.classList.toggle('selected', c.dataset.currency===currencyCode));
        resetScreenScroll(currencyFS);
      });
      currencyFSBackdrop.addEventListener('click',(e)=>{ if(e.target===currencyFSBackdrop){ currencyFS.style.display='none'; currencyFSBackdrop.style.display='none'; openSettingsFS(); } });
      currencyBackBtn.addEventListener('click',()=>{ currencyFS.style.display='none'; currencyFSBackdrop.style.display='none'; openSettingsFS(); });
      currencyChoices.forEach(btn=>{
        btn.addEventListener('click',()=>{
          setCurrency(btn.dataset.currency);
        });
      });

      openTermsBtn.addEventListener('click', ()=>{
        openExternal('https://docs.google.com/document/d/e/2PACX-1vTy-CjnddzjY9QULBHaYlNt1NHWLM5-vs25STZota20TNKKpofOyHefUjkaebHKeOkY2yWbo-5j8x3J/pub');
      });
      openPrivacyBtn.addEventListener('click', ()=>{
        openExternal('https://docs.google.com/document/d/e/2PACX-1vTEs0TDUWNq_aPya5SnPzajfXQW-l0mRdfdX1mC85j4cSgUfnHVk7RiiHCxQJj1qLIQTqpJQjxi6CGV/pub');
      });

      openReportBtn.addEventListener('click', ()=>{
        settingsFSBackdrop.style.display='none'; settingsFS.style.display='none';
        reportFSBackdrop.style.display='block'; reportFS.style.display='flex'; resetScreenScroll(reportFS);
      });
      reportFSBackdrop.addEventListener('click',(e)=>{ if(e.target===reportFSBackdrop){ reportFS.style.display='none'; reportFSBackdrop.style.display='none'; openSettingsFS(); } });
      reportBackBtn.addEventListener('click',()=>{ reportFS.style.display='none'; reportFSBackdrop.style.display='none'; openSettingsFS(); });

      openAboutBtn.addEventListener('click', ()=>{
        settingsFSBackdrop.style.display='none'; settingsFS.style.display='none';
        aboutFSBackdrop.style.display='block'; aboutFS.style.display='flex'; 
        applyCapsToSentenceParagraphs();
        resetScreenScroll(aboutFS);
      });
      aboutFSBackdrop.addEventListener('click',(e)=>{ if(e.target===aboutFSBackdrop){ aboutFS.style.display='none'; aboutFSBackdrop.style.display='none'; openSettingsFS(); } });
      aboutBackBtn.addEventListener('click',()=>{ aboutFS.style.display='none'; aboutFSBackdrop.style.display='none'; openSettingsFS(); });

      welcomeContinueBtn.addEventListener('click', ()=>{
        welcomeModal.style.display='none';
        welcomeModalBackdrop.style.display='none';
        trySet(WELCOME_SEEN_KEY, '1');
        unlockBodyScroll();
      });

      deleteDataBtn.addEventListener('click', ()=>{
        refreshDeleteMessage();
        deleteDataBackdrop.style.display='block';
        deleteDataDialog.style.display='block';
        resetScreenScroll(deleteDataDialog);
      });
      deleteCancelBtn.addEventListener('click', ()=>{
        deleteDataBackdrop.style.display='none';
        deleteDataDialog.style.display='none';
      });
      deleteDataBackdrop.addEventListener('click',(e)=>{ if(e.target===deleteDataBackdrop){ deleteDataBackdrop.style.display='none'; deleteDataDialog.style.display='none'; } });
      deleteConfirmBtn.addEventListener('click', async ()=>{
        try{
          const keysToRemove=[];
          for(let i=0;i<localStorage.length;i++){
            const k=localStorage.key(i);
            if(!k) continue;
            if(/^photo-\d{4}-\d{2}-\d{2}$/.test(k) ||
               /^(note|icon|word|song|movie|show|notesText|notesIcon)-\d{4}-\d{2}-\d{2}$/.test(k) ||
               k===CART_KEY){
              keysToRemove.push(k);
            }
          }
          keysToRemove.forEach(k=>localStorage.removeItem(k));
          photoCache={};
          emojiCache={};
          
          // Also clear IndexedDB photos
          try{
            const db = await idbOpen();
            const transaction = db.transaction([IDB_STORE_NAME], 'readwrite');
            const store = transaction.objectStore(IDB_STORE_NAME);
            await new Promise((resolve, reject) => {
              const request = store.clear();
              request.onsuccess = () => resolve();
              request.onerror = () => reject(new Error('Failed to clear IndexedDB'));
            });
            
            // Revoke all object URLs
            Object.values(photoObjectURLCache).forEach(url => {
              if(url) URL.revokeObjectURL(url);
            });
            photoObjectURLCache = {};
          }catch(idbErr){
            console.error('Failed to clear IndexedDB:', idbErr);
          }
        }catch(e){}
        deleteDataBackdrop.style.display='none';
        deleteDataDialog.style.display='none';
        closeSettingsFS();
        showToast('deleted');
        preloadYearAssets(YEAR);
        buildYear(YEAR);
      });

      capsNoneBtn.addEventListener('click',()=> setCapsMode('none'));
      capsStandardBtn.addEventListener('click',()=> setCapsMode('standard'));
      capsAllBtn.addEventListener('click',()=> setCapsMode('all'));

      fontsChoices.forEach(btn=>{
        btn.addEventListener('click',()=> applyFont(btn.dataset.font,true));
      });

      themeChoices.forEach(btn=>{
        btn.addEventListener('click',()=> applyTheme(btn.dataset.theme,true));
      });

      function openSettingsFS(){
        lockBodyScroll();
        settingsFSBackdrop.style.display='block';
        settingsFS.style.display='flex';
        resetScreenScroll(settingsFS);
      }
      function closeSettingsFS(){
        settingsFSBackdrop.style.display='none';
        settingsFS.style.display='none';
        unlockBodyScroll();
      }

      function refreshCapsSelectionUI(){
        [capsNoneBtn,capsStandardBtn,capsAllBtn].forEach(b=>b.classList.remove('selected'));
        if(capsMode==='none') capsNoneBtn.classList.add('selected');
        else if(capsMode==='standard') capsStandardBtn.classList.add('selected');
        else if(capsMode==='all') capsAllBtn.classList.add('selected');
      }
      function setCapsMode(mode){
        if(!['none','standard','all'].includes(mode)) return;
        if(capsMode===mode) return;
        capsMode=mode;
        trySet(CAPS_KEY,capsMode);
        applyCapsMode(capsMode,true);
        refreshCapsSelectionUI();
      }

      function applyCapsMode(mode,refreshUI){
        document.documentElement.setAttribute('data-caps',mode);
        if(!refreshUI) return;
        const allMonthHeaders=document.querySelectorAll('#calCarousel .month h2');
        allMonthHeaders.forEach((h2,idx)=>{
          const m=idx % 12;
          h2.textContent=monthName(YEAR,m);
        });
        updateDeliveryFeeLabel();
        refreshDeleteMessage();
        refreshProductDescriptions();
        applyCapsToSentenceParagraphs();
        if(selectedDateKey && dayModal.style.display==='flex'){
          const m=selectedDateKey.match(/^photo-(\d{4})-(\d{2})-(\d{2})$/);
          if(m){ setDayTitle(+m[1],+m[2]-1,+m[3]); }
          if(isEditMode){
            loadFieldsIntoEditUI();
          }else{
            refreshSummaryFromStorage();
            polaroidSummary.style.display=polaroid.classList.contains('has-summary')?'block':'none';
            bigPreviewPlaceholder.style.display='none';
          }
          resetScreenScroll(dayModal);
        }
      }

      function applyCapsToSentenceParagraphs(){
        const BASE_ABOUT_TEXT = 'the memory calendar is a place for journaling, saving memories and creating art. there are no ads or in-app purchases but there is an in-app store where you can purchase your beautiful custom daily polaroids and monthly posters. as a solo passion project, every purchase is greatly appreciated and helps in future developments!';
        const paragraphs = document.querySelectorAll('[data-caps-sentence]');
        paragraphs.forEach(p => {
          let text = BASE_ABOUT_TEXT;
          if(capsMode === 'none') {
            text = text.toLowerCase();
          } else if(capsMode === 'all') {
            text = text.toUpperCase();
          } else if(capsMode === 'standard') {
            text = sentenceCase(text);
          }
          p.textContent = text;
        });
      }

      yearTitleEl.addEventListener('click', openYearPicker);
      yearBackdrop.addEventListener('click',(e)=>{ if(e.target===yearBackdrop) closeYearPicker(); });
      yearBackBtn.addEventListener('click', closeYearPicker);
      yearOptions.addEventListener('click',(e)=>{
        const btn=e.target.closest('.year-choice');
        if(!btn) return;
        const y=Number(btn.dataset.year);
        if(Number.isFinite(y) && y!==YEAR){
          YEAR=y;
          yearTitleEl.textContent=String(YEAR);
          localStorage.setItem(YEAR_KEY, String(YEAR));
          preloadYearAssets(YEAR);
          buildYear(YEAR);
          applyCapsMode(capsMode,true);
        }
        closeYearPicker();
      });

      function openYearPicker(){
        let html='';
        for(let y=MAX_YEAR;y>=MIN_YEAR;y--){
          html+=`<button class="choice-btn year-choice${y===YEAR?' selected':''}" data-year="${y}">${y}</button>`;
        }
        yearOptions.innerHTML=html;
        lockBodyScroll();
        yearBackdrop.style.display='block';
        yearModal.style.display='flex';
        resetScreenScroll(yearModal);
      }
      function closeYearPicker(){
        yearModal.style.display='none';
        yearBackdrop.style.display='none';
        unlockBodyScroll();
      }

      dayBackdrop.addEventListener('click', ()=>{ closeDayModal(); });
      function closeDayModal(){
        // Clean up object URL if it exists
        if(draftPhotoObjectURL){
          URL.revokeObjectURL(draftPhotoObjectURL);
          draftPhotoObjectURL=null;
        }
        
        dayModal.style.display='none';
        dayBackdrop.style.display='none';
        unlockBodyScroll();
        resetScreenScroll(document.body);
      }
      function lockBodyScroll(){
        const y=window.scrollY||document.documentElement.scrollTop||0;
        document.body.classList.add('lock-scroll','sheet-open');
        document.body.style.top=`-${y}px`;
        lockBodyScroll._y=y;
      }
      function unlockBodyScroll(){
        document.body.classList.remove('lock-scroll','sheet-open');
        const y=lockBodyScroll._y||0;
        document.body.style.top='';
        window.scrollTo(0,y);
      }

      function setupInfiniteCarousel(){
        carousel.querySelectorAll('.cal-page.clone').forEach(n=>n.remove());
        const lastClone=calEmoji.cloneNode(true); lastClone.classList.add('clone');
        const firstClone=calPhoto.cloneNode(true); firstClone.classList.add('clone');
        carousel.insertBefore(lastClone,calPhoto);
        carousel.appendChild(firstClone);
        requestAnimationFrame(()=>{
          carousel.style.scrollBehavior='auto';
          carousel.scrollLeft=carousel.clientWidth*1;
          carousel.style.scrollBehavior='';
          applyCapsMode(capsMode,true);
          window.scrollTo(0,0);
        });
        if(!carousel._wrapListenerAdded){
          let t;
          carousel.addEventListener('scroll',()=>{
            clearTimeout(t);
            t=setTimeout(handleWrap,60);
          },{passive:true});
          window.addEventListener('resize',()=>{
            const idx=Math.round(carousel.scrollLeft/Math.max(1,carousel.clientWidth));
            carousel.style.scrollBehavior='auto';
            carousel.scrollLeft=carousel.clientWidth*idx;
            carousel.style.scrollBehavior='';
          });
          carousel._wrapListenerAdded=true;
        }
      }
      function handleWrap(){
        const w=Math.max(1,carousel.clientWidth);
        const idx=Math.round(carousel.scrollLeft/w);
        if(idx===0){
          carousel.style.scrollBehavior='auto';
          carousel.scrollLeft=w*2;
          carousel.style.scrollBehavior='';
        }else if(idx>=3){
          carousel.style.scrollBehavior='auto';
          carousel.scrollLeft=w*1;
          carousel.style.scrollBehavior='';
        }
      }

      cartBtn.addEventListener('click', openStoreFS);
      storeFSBackdrop.addEventListener('click',(e)=>{ if(e.target===storeFSBackdrop) closeStoreFS(); });
      storeBackBtn.addEventListener('click', closeStoreFS);
      storeDayPolaroidBtn.addEventListener('click', ()=>{ storeMode='day'; openStoreYearFS(); });
      storeMonthPosterBtn.addEventListener('click', ()=>{ storeMode='poster'; openStoreYearFS(); });
      storeCartBtn.addEventListener('click', openStoreCartFS);

      storeYearBackdrop.addEventListener('click',(e)=>{ if(e.target===storeYearBackdrop){ closeStoreYearFS(); openStoreFS(); } });
      storeYearBackBtn.addEventListener('click',()=>{ closeStoreYearFS(); openStoreFS(); });

      storeMonthBackdrop.addEventListener('click',(e)=>{ if(e.target===storeMonthBackdrop){
        closeStoreMonthFS(); openStoreYearFS();
      }});
      storeMonthBackBtn.addEventListener('click',()=>{ closeStoreMonthFS(); openStoreYearFS(); });

      storePosterBackdrop.addEventListener('click',(e)=>{ if(e.target===storePosterBackdrop){
        closeStorePosterFS(); openStoreMonthFS(currentStoreYear);
      }});
      storePosterBackBtn.addEventListener('click',()=>{ closeStorePosterFS(); openStoreMonthFS(currentStoreYear); });

      storeDateBackdrop.addEventListener('click',(e)=>{ if(e.target===storeDateBackdrop){ closeStoreDateFS(); openStoreMonthFS(currentStoreYear); } });
      storeDateBackBtn.addEventListener('click',()=>{ closeStoreDateFS(); openStoreMonthFS(currentStoreYear); });

      storePolaroidBackdrop.addEventListener('click',(e)=>{ if(e.target===storePolaroidBackdrop){
        closeStorePolaroidFS(); openStoreDateFS(currentStoreYear,currentStoreMonth);
      }});
      storePolaroidBackBtn.addEventListener('click',()=>{ closeStorePolaroidFS(); openStoreDateFS(currentStoreYear,currentStoreMonth); });

      // Image selection for day editing screen only
      let selectedImageFile = null;
      let currentFrameTransform = { scale: 1, x: 0, y: 0 };
      let baselineScale = 1; // Dynamic minimum scale based on cover-fit
      const MAX_FRAME_SCALE = 5;
      const SQUARE_ASPECT_TOLERANCE = 0.05; // Tolerance for detecting square images

      // Wire image selection to day edit screen (polaroidImgWrap in dayModal)
      polaroidImgWrap.addEventListener('click', ()=> {
        if (isEditMode && chooserInput) chooserInput.click();
      });

      if (bigPreviewPlaceholder) {
        bigPreviewPlaceholder.addEventListener('click', (e)=> {
          e.stopPropagation(); // Prevent parent polaroidImgWrap from also triggering
          if (isEditMode && chooserInput) chooserInput.click();
        });
      }

      chooserInput.addEventListener('change', (e)=> {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        selectedImageFile = file;
        openFrameModal(file);
      });

      function openFrameModal(file) {
        // Use object URL for preview instead of reading as data URL
        const objectUrl = URL.createObjectURL(file);
        frameImg.src = objectUrl;
        frameImg.onload = ()=> {
          // Show modal BEFORE measuring viewport dimensions
          frameModal.style.display = 'flex';
          
          // Calculate initial scale based on image aspect ratio
          const S = frameViewport.offsetWidth; // Square frame (S√óS)
          const imgWidth = frameImg.naturalWidth;
          const imgHeight = frameImg.naturalHeight;
          const imgAspect = imgWidth / imgHeight;
          
          let scale, x, y;
          
          if (Math.abs(imgAspect - 1) < SQUARE_ASPECT_TOLERANCE) {
            // Square image: fills frame exactly
            scale = S / imgWidth;
            x = 0;
            y = 0;
          } else if (imgAspect < 1) {
            // Portrait image: width = frame width, vertically centered with overflow
            scale = S / imgWidth;
            x = 0;
            y = (S - imgHeight * scale) / 2;
          } else {
            // Landscape image: height = frame height, horizontally centered with overflow
            scale = S / imgHeight;
            x = (S - imgWidth * scale) / 2;
            y = 0;
          }
          
          baselineScale = scale; // Store as minimum allowed scale
          currentFrameTransform = { scale, x, y };
          applyFrameTransform();
        };
      }

      function closeFrameModal() {
        // Revoke object URL to prevent memory leaks
        if (frameImg.src && frameImg.src.startsWith('blob:')) {
          URL.revokeObjectURL(frameImg.src);
        }
        frameModal.style.display = 'none';
        frameImg.src = '';
        currentFrameTransform = { scale: 1, x: 0, y: 0 };
        baselineScale = 1;
        if (chooserInput) chooserInput.value = '';
      }

      function clampPan() {
        // Prevent panning from revealing blank space
        const S = frameViewport.offsetWidth; // Square frame
        const imgWidth = frameImg.naturalWidth;
        const imgHeight = frameImg.naturalHeight;
        
        // Validate image is loaded
        if (!imgWidth || !imgHeight) return;
        
        const { scale } = currentFrameTransform;
        
        const scaledImgWidth = imgWidth * scale;
        const scaledImgHeight = imgHeight * scale;
        
        // Calculate allowed pan range to ensure image covers frame
        // x range: [S - scaledImgWidth, 0] (image must cover left and right)
        // y range: [S - scaledImgHeight, 0] (image must cover top and bottom)
        const maxX = 0;
        const minX = Math.min(0, S - scaledImgWidth);
        const maxY = 0;
        const minY = Math.min(0, S - scaledImgHeight);
        
        // Clamp x and y to prevent blank space
        currentFrameTransform.x = Math.max(minX, Math.min(maxX, currentFrameTransform.x));
        currentFrameTransform.y = Math.max(minY, Math.min(maxY, currentFrameTransform.y));
      }

      function applyFrameTransform() {
        const { scale, x, y } = currentFrameTransform;
        frameImg.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
      }

      // Helper function to convert viewport coordinates to image space
      function convertViewportToImageSpace(vpX, vpY, oldScale) {
        const imgX = (vpX - currentFrameTransform.x) / oldScale;
        const imgY = (vpY - currentFrameTransform.y) / oldScale;
        return { imgX, imgY };
      }

      // Frame modal pan/zoom with touch
      let isDragging = false;
      let lastTouchX = 0;
      let lastTouchY = 0;
      let lastTouchDist = 0;

      frameViewport.addEventListener('touchstart', (e)=> {
        if (e.touches.length === 1) {
          isDragging = true;
          lastTouchX = e.touches[0].clientX;
          lastTouchY = e.touches[0].clientY;
        } else if (e.touches.length === 2) {
          isDragging = false;
          const dx = e.touches[1].clientX - e.touches[0].clientX;
          const dy = e.touches[1].clientY - e.touches[0].clientY;
          lastTouchDist = Math.sqrt(dx * dx + dy * dy);
        }
      }, { passive: true });

      frameViewport.addEventListener('touchmove', (e)=> {
        if (e.touches.length === 1 && isDragging) {
          e.preventDefault();
          const touchX = e.touches[0].clientX;
          const touchY = e.touches[0].clientY;
          const dx = touchX - lastTouchX;
          const dy = touchY - lastTouchY;
          currentFrameTransform.x += dx;
          currentFrameTransform.y += dy;
          lastTouchX = touchX;
          lastTouchY = touchY;
          clampPan();
          applyFrameTransform();
        } else if (e.touches.length === 2) {
          e.preventDefault();
          const dx = e.touches[1].clientX - e.touches[0].clientX;
          const dy = e.touches[1].clientY - e.touches[0].clientY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (lastTouchDist > 0) {
            // Calculate gesture center
            const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
            const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
            
            // Get viewport position
            const rect = frameViewport.getBoundingClientRect();
            const vpX = centerX - rect.left;
            const vpY = centerY - rect.top;
            
            // Convert to image space before scaling
            const oldScale = currentFrameTransform.scale;
            const { imgX, imgY } = convertViewportToImageSpace(vpX, vpY, oldScale);
            
            // Apply scale
            const scaleDelta = dist / lastTouchDist;
            const newScale = Math.max(baselineScale, Math.min(MAX_FRAME_SCALE, oldScale * scaleDelta));
            currentFrameTransform.scale = newScale;
            
            // Adjust translation to keep focal point fixed
            currentFrameTransform.x = vpX - imgX * newScale;
            currentFrameTransform.y = vpY - imgY * newScale;
            
            clampPan();
            applyFrameTransform();
          }
          lastTouchDist = dist;
        }
      }, { passive: false });

      frameViewport.addEventListener('touchend', ()=> {
        isDragging = false;
        lastTouchDist = 0;
      }, { passive: true });

      // Mouse support for frame modal
      let isMouseDragging = false;
      let lastMouseX = 0;
      let lastMouseY = 0;

      frameViewport.addEventListener('mousedown', (e)=> {
        isMouseDragging = true;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
        e.preventDefault();
      });

      frameViewport.addEventListener('mousemove', (e)=> {
        if (isMouseDragging) {
          const dx = e.clientX - lastMouseX;
          const dy = e.clientY - lastMouseY;
          currentFrameTransform.x += dx;
          currentFrameTransform.y += dy;
          lastMouseX = e.clientX;
          lastMouseY = e.clientY;
          clampPan();
          applyFrameTransform();
          e.preventDefault();
        }
      });

      frameViewport.addEventListener('mouseup', ()=> {
        isMouseDragging = false;
      });

      frameViewport.addEventListener('wheel', (e)=> {
        e.preventDefault();
        
        // Calculate cursor position relative to viewport
        const rect = frameViewport.getBoundingClientRect();
        const vpX = e.clientX - rect.left;
        const vpY = e.clientY - rect.top;
        
        // Convert to image space before scaling
        const oldScale = currentFrameTransform.scale;
        const { imgX, imgY } = convertViewportToImageSpace(vpX, vpY, oldScale);
        
        // Apply scale
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        const newScale = Math.max(baselineScale, Math.min(MAX_FRAME_SCALE, oldScale * delta));
        currentFrameTransform.scale = newScale;
        
        // Adjust translation to keep cursor position fixed
        currentFrameTransform.x = vpX - imgX * newScale;
        currentFrameTransform.y = vpY - imgY * newScale;
        
        clampPan();
        applyFrameTransform();
      }, { passive: false });

      frameUseBtn.addEventListener('click', async ()=> {
        // Capture the framed image and save to day edit draft at high quality
        try {
          const S = frameViewport.offsetWidth; // Square frame size (CSS pixels)
          
          // Export at high resolution for quality preservation
          const exportScale = EXPORT_SCALE_MULTIPLIER;
          const exportSize = S * exportScale;
          
          const canvas = document.createElement('canvas');
          canvas.width = exportSize;
          canvas.height = exportSize;
          const ctx = canvas.getContext('2d', { alpha: false });
          
          // Ensure pan is clamped before capture to prevent blank space
          clampPan();
          
          const { scale, x, y } = currentFrameTransform;
          const imgWidth = frameImg.naturalWidth;
          const imgHeight = frameImg.naturalHeight;
          
          // Scale all transform values for high-res export
          ctx.save();
          ctx.translate(x * exportScale, y * exportScale);
          ctx.scale(scale * exportScale, scale * exportScale);
          
          // Use high quality image smoothing
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          
          ctx.drawImage(frameImg, 0, 0, imgWidth, imgHeight);
          ctx.restore();
          
          // Create blob once for both data URL and object URL (efficient)
          const blob = await canvasToBlob(canvas, EXPORT_QUALITY);
          
          // Convert blob to data URL for storage with error handling
          const reader = new FileReader();
          draftPhotoData = await new Promise((resolve, reject) => {
            reader.onload = () => resolve(reader.result);
            reader.onerror = () => reject(new Error('Failed to read blob as data URL'));
            reader.readAsDataURL(blob);
          });
          
          // Revoke previous object URL if exists
          if (draftPhotoObjectURL) {
            URL.revokeObjectURL(draftPhotoObjectURL);
          }
          
          // Create object URL for preview (avoids re-encoding)
          draftPhotoObjectURL = URL.createObjectURL(blob);
          bigPreviewImg.src = draftPhotoObjectURL;
          bigPreviewImg.style.display = 'block';
          bigPreviewPlaceholder.style.display = 'none';
          
          closeFrameModal();
        } catch (err) {
          console.error('Failed to capture framed image:', err);
          closeFrameModal();
        }
      });

      frameCancelBtn.addEventListener('click', ()=> {
        closeFrameModal();
      });

      storeCartBackdrop.addEventListener('click',(e)=>{ if(e.target===storeCartBackdrop){ closeStoreCartFS(); openStoreFS(); } });
      storeCartBackBtn.addEventListener('click',()=>{ closeStoreCartFS(); openStoreFS(); });

      storePolaroidBuyBtn.addEventListener('click', async ()=>{
        await addCurrentPolaroidToCart();
        renderCart();
      });

      storePosterBuyBtn.addEventListener('click', async ()=>{
        await addCurrentPosterToCart();
        renderCart();
      });

      cartItemsList.addEventListener('click',(e)=>{
        const btn=e.target.closest('.cart-del-btn');
        if(!btn) return;
        const idx=Number(btn.dataset.index);
        if(Number.isFinite(idx)){
          cartItems.splice(idx,1);
          saveCartItems();
          renderCart();
        }
      });

      storeCartTotalBtn.addEventListener('click', openCheckoutFS);
      checkoutBackBtn.addEventListener('click', closeCheckoutFS);
      checkoutFSBackdrop.addEventListener('click',(e)=>{ if(e.target===checkoutFSBackdrop) closeCheckoutFS(); });

      tncBox.addEventListener('click',()=>{
        tncBox.classList.toggle('checked');
        tncBox.textContent=tncBox.classList.contains('checked')?'‚úì':'';
        tncBox.setAttribute('aria-checked', tncBox.classList.contains('checked')?'true':'false');
      });
      nonRefundBox.addEventListener('click',()=>{
        nonRefundBox.classList.toggle('checked');
        nonRefundBox.textContent=nonRefundBox.classList.contains('checked')?'‚úì':'';
        nonRefundBox.setAttribute('aria-checked', nonRefundBox.classList.contains('checked')?'true':'false');
      });

      if (orderAndPayBtn) {
        orderAndPayBtn.addEventListener('click', handleOrderAndPay);
      }

      if (orderStatusBackBtn) {
        orderStatusBackBtn.addEventListener('click', () => {
          window.history.replaceState({}, document.title, window.location.pathname);
          if (orderStatusOverlay) {
            orderStatusOverlay.style.display = 'none';
          }
        });
      }

      let currentStoreYear=null;
      let currentStoreMonth=null;

      function openStoreFS(){
        lockBodyScroll();
        storeFSBackdrop.style.display='block';
        storeFS.style.display='flex';
        resetScreenScroll(storeFS);
      }
      function closeStoreFS(){
        storeFSBackdrop.style.display='none';
        storeFS.style.display='none';
        unlockBodyScroll();
      }

      function openStoreYearFS(){
        storeFSBackdrop.style.display='none';
        storeFS.style.display='none';
        buildStoreYearButtons();
        storeYearBackdrop.style.display='block';
        storeYearFS.style.display='flex';
        resetScreenScroll(storeYearFS);
      }
      function closeStoreYearFS(){
        storeYearBackdrop.style.display='none';
        storeYearFS.style.display='none';
      }
      function buildStoreYearButtons(){
        let html='';
        for(let y=MAX_YEAR;y>=MIN_YEAR;y--){
          html+=`<button class="action-btn store-year-btn" data-year="${y}">${y}</button>`;
        }
        storeYearButtons.innerHTML=html;
        storeYearButtons.querySelectorAll('.store-year-btn').forEach(btn=>{
          btn.addEventListener('click',()=>{
            currentStoreYear=Number(btn.dataset.year);
            openStoreMonthFS(currentStoreYear);
          });
        });
      }

      function openStoreMonthFS(year){
        closeStoreYearFS();
        buildStoreMonthButtons(year);
        storeMonthBackdrop.style.display='block';
        storeMonthFS.style.display='flex';
        resetScreenScroll(storeMonthFS);
      }
      function closeStoreMonthFS(){
        storeMonthBackdrop.style.display='none';
        storeMonthFS.style.display='none';
      }
      function buildStoreMonthButtons(year){
        const months=[
          'January','February','March','April','May','June',
          'July','August','September','October','November','December'
        ];
        let html='';
        for(let i=0;i<12;i++){
          const label=applyMonthCase(months[i]);
          html+=`<button class="action-btn store-month-btn" data-month="${i+1}">${label}</button>`;
        }
        storeMonthButtons.innerHTML=html;
        storeMonthButtons.querySelectorAll('.store-month-btn').forEach(btn=>{
          btn.addEventListener('click',()=>{
            currentStoreMonth=Number(btn.dataset.month);
            if(storeMode==='day') openStoreDateFS(year,currentStoreMonth);
            else openStorePosterFS(year,currentStoreMonth);
          });
        });
      }
      function applyMonthCase(str){
        if(capsMode==='none') return str.toLowerCase();
        if(capsMode==='all') return str.toUpperCase();
        return str;
      }

      function openStoreDateFS(year,month){
        closeStoreMonthFS();
        buildStoreDateButtons(year,month);
        storeDateBackdrop.style.display='block';
        storeDateFS.style.display='flex';
        resetScreenScroll(storeDateFS);
      }
      function closeStoreDateFS(){
        storeDateBackdrop.style.display='none';
        storeDateFS.style.display='none';
      }
      function daysInMonth(year,month){ return new Date(year,month,0).getDate(); }
      function buildStoreDateButtons(year,month){
        const days=daysInMonth(year,month);
        let html='';
        for(let d=1;d<=days;d++){
          html+=`<button class="action-btn store-date-btn" data-day="${d}">${d}</button>`;
        }
        storeDateButtons.innerHTML=html;
        storeDateButtons.querySelectorAll('.store-date-btn').forEach(btn=>{
          btn.addEventListener('click',()=>{
            const day=Number(btn.dataset.day);
            openStorePolaroidFS(year,month,day);
          });
        });
      }

      async function openStorePolaroidFS(year,month,day){
        closeStoreDateFS();
        await buildStorePolaroid(year,month,day);
        storePolaroidBackdrop.style.display='block';
        storePolaroidFS.style.display='flex';
        resetScreenScroll(storePolaroidFS);
        positionStorePolaroidSummary();
      }
      function closeStorePolaroidFS(){
        storePolaroidBackdrop.style.display='none';
        storePolaroidFS.style.display='none';
      }

      async function buildStorePolaroid(year,month,day){
        storePolaroidTitle.textContent='daily polaroid';
        const dateKey=makeKey(year,month,day);
        
        // Load photo from IndexedDB (prefer full, fallback to thumbnail)
        const photo = await getSavedPhotoForDayView(dateKey, true);
        
        const base=baseDateKey(dateKey);
        const note=(tryGet(`note-${base}`)||'').trim();
        const icon=(tryGet(`icon-${base}`)||'').trim();
        const word=(tryGet(`word-${base}`)||'').trim();
        const song=(tryGet(`song-${base}`)||'').trim();
        const movie=(tryGet(`movie-${base}`)||'').trim();
        const show=(tryGet(`show-${base}`)||'').trim();
        const notesText=(tryGet(`notesText-${base}`)||'').trim();
        const notesIcon=(tryGet(`notesIcon-${base}`)||'').trim();

        if(photo){
          storePolaroidImg.src=photo;
          storePolaroidImg.style.display='block';
        }else{
          storePolaroidImg.src='';
          storePolaroidImg.style.display='none';
        }
        // Store product screen is read-only, never show placeholder
        if (storePolaroidPlaceholder) {
          storePolaroidPlaceholder.style.display='none';
        }

        const blocks=[];
        const dateLine = formatFullDate(year,month,day);
        if(dateLine) blocks.push(dateLine);
        
        // Detect mode: notes-mode if notesText or notesIcon exists
        const isNotesMode = !!(notesText || notesIcon);
        
        if(isNotesMode){
          // Notes-mode rendering: show notes text (preserve line breaks), NO emoji in preview
          if(notesText) blocks.push(notesText);
        }else{
          // Standard-mode rendering: show all six categories with emoji
          if(note) blocks.push(note);
          const meta=[];
          if(word) meta.push(transformForDisplay(word,'word'));
          if(icon) meta.push(icon);
          if(meta.length) blocks.push(meta.join('\n'));
          const media=[];
          if(song) media.push(`üé∂ ${transformForDisplay(song,'text')} üé∂`);
          if(movie) media.push(`üéü ${transformForDisplay(movie,'text')} üéü`);
          if(show) media.push(`üì∫ ${transformForDisplay(show,'text')} üì∫`);
          if(media.length) blocks.push(media.join('\n'));
        }
        
        storePolaroidSummary.textContent=blocks.join('\n');
        document.getElementById('storePolaroidCard').classList.add('has-summary');
        document.getElementById('storePolaroidCard').classList.remove('solo-photo');
        refreshProductDescriptions();
        positionStorePolaroidSummary();
        updateCurrencyUI();
      }

      async function openStorePosterFS(year,month){
        closeStoreMonthFS();
        await buildStorePoster(year,month);
        storePosterBackdrop.style.display='block';
        storePosterFS.style.display='flex';
        resetScreenScroll(storePosterFS);
      }
      function closeStorePosterFS(){
        storePosterBackdrop.style.display='none';
        storePosterFS.style.display='none';
      }

      async function buildStorePoster(year,month){
        storePosterTitle.textContent='monthly poster';

        document.getElementById('storePosterImgWrap').innerHTML='';
        storePosterImg.style.display='none';
        let contentSection=null;
        if(year===YEAR){
          const monthSections=calPhoto.querySelectorAll('.month');
          const clone=monthSections[month-1]?.cloneNode(true);
          if(clone){ contentSection=clone; }
        }
        if(!contentSection){
          const section=document.createElement('section');
          section.className='month';
          const h2=document.createElement('h2');
          h2.textContent=monthName(year,month-1);
          section.appendChild(h2);
          const grid=document.createElement('div'); grid.className='grid'; section.appendChild(grid);
          const first=new Date(year,month-1,1);
          const days=new Date(year,month,0).getDate();
          const mondayIndex=(first.getDay()+6)%7;
          for(let i=0;i<mondayIndex;i++){
            const pad=document.createElement('div'); pad.className='pad'; grid.appendChild(pad);
          }
          
          // Load thumbnails asynchronously for each day
          const loadPromises = [];
          for(let d=1;d<=days;d++){
            const key=makeKey(year,month,d);
            const cell=document.createElement('div');
            cell.className='day';
            cell.dataset.date=key; cell.dataset.y=year; cell.dataset.m=month; cell.dataset.d=d;
            const num=document.createElement('div'); num.className='num'; num.textContent=d; cell.appendChild(num);
            const img=document.createElement('img'); img.alt=`${h2.textContent} ${d} photo`; img.loading='eager'; img.decoding='sync'; cell.appendChild(img);
            
            // Try sync first
            const saved=getSavedPhoto(key);
            if(saved){ 
              img.src=saved; 
              img.style.display='block'; 
              cell.classList.add('has-photo'); 
            } else {
              // Load async from IndexedDB
              loadPromises.push(
                (async () => {
                  const thumbUrl = await getSavedPhotoThumbnail(key);
                  if(thumbUrl){
                    img.src=thumbUrl;
                    img.style.display='block';
                    cell.classList.add('has-photo');
                  }
                })()
              );
            }
            
            grid.appendChild(cell);
          }
          
          // Wait for all thumbnails to load
          if(loadPromises.length > 0){
            await Promise.all(loadPromises);
          }
          
          contentSection=section;
        }
        const headerEl=contentSection.querySelector('h2');
        if(headerEl){
          const monthText=headerEl.textContent.split(/\s+/)[0];
          headerEl.textContent=monthText + ' 2025';
          headerEl.style.display='none';
        }
        const gridEl=contentSection.querySelector('.grid');
        if(gridEl){
          gridEl.querySelectorAll('.pad').forEach(p=>p.remove());
        }

        const square=document.createElement('div');
        square.className='poster-square';
        document.getElementById('storePosterImgWrap').appendChild(square);
        square.appendChild(contentSection);

        let overlay=document.createElement('div');
        overlay.className='poster-title-overlay';
        overlay.textContent=(headerEl && headerEl.textContent) ? headerEl.textContent : '';
        square.appendChild(overlay);

        layoutPosterSquare(square, contentSection);
        applySqueezedGradient(square);
        positionPosterEvenSpacing(square, contentSection, overlay);

        setTimeout(()=>{
          positionPosterEvenSpacing(square, contentSection, overlay);
        },80);

        if(!window._posterResizeBound){
          window.addEventListener('resize', ()=> {
            const sq=document.querySelector('#storePosterImgWrap .poster-square');
            const cont=sq && sq.querySelector('.month');
            const ov=sq && sq.querySelector('.poster-title-overlay');
            if(sq && cont){
              layoutPosterSquare(sq,cont);
              applySqueezedGradient(sq);
              positionPosterEvenSpacing(sq,cont,ov);
            }
          });
          window._posterResizeBound=true;
        }
        refreshProductDescriptions();
        updateCurrencyUI();
      }

      function applySqueezedGradient(squareEl){
        if(!squareEl) return;
        const topbarH=parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--topbar-h'))||64;
        const bodyH=window.innerHeight||1000;
        const topPct=Math.min(100,(topbarH+1)/bodyH*100);
        squareEl.style.background=`linear-gradient(180deg,var(--bg1) 0%, var(--bg1) ${topPct}%, var(--bg2) 55%, var(--bg3) 100%)`;
      }

      function positionPosterEvenSpacing(squareEl, contentEl, overlayEl){
        if(!squareEl || !contentEl || !overlayEl) return;
        const grid = contentEl.querySelector('.grid');
        if(!grid) return;
        const sqRect = squareEl.getBoundingClientRect();

        overlayEl.style.visibility='hidden';
        overlayEl.style.top='0px';
        const T = overlayEl.getBoundingClientRect().height || 0;

        const gridRect = grid.getBoundingClientRect();
        const G = gridRect.height || 0;
        const S = sqRect.height || 1;

        const gap = (S - (T + G)) / 3;
        if(gap < 0) { overlayEl.style.visibility='visible'; return; }

        overlayEl.style.top = Math.round(gap) + 'px';
        overlayEl.style.visibility='visible';

        const desiredGridTop = Math.round((sqRect.top + gap) + T + gap);
        const currentGridTop = Math.round(grid.getBoundingClientRect().top);
        const delta = desiredGridTop - currentGridTop;
        contentEl.style.top = `calc(50% + ${delta}px)`;
      }

      function layoutPosterSquare(squareEl, contentEl){
        if(!squareEl || !contentEl) return;
        contentEl.style.position='static';
        contentEl.style.transform='none';
        contentEl.style.left='0';
        contentEl.style.top='0';
        contentEl.style.width='100%';
        contentEl.style.visibility='hidden';
        requestAnimationFrame(()=>{
          const squareRect = squareEl.getBoundingClientRect();
          const W = squareRect.width || squareEl.clientWidth || 1;
          const h = contentEl.getBoundingClientRect().height || contentEl.scrollHeight || 1;
          let scale = 1;
          if(h > W) scale = W / h;
          scale *= 0.9;
          contentEl.style.position='absolute';
          contentEl.style.left='50%';
          contentEl.style.top='50%';
          contentEl.style.transformOrigin='50% 50%';
          contentEl.style.transform=`translate(-50%,-50%) scale(${scale})`;
          contentEl.style.visibility='visible';
        });
      }

      function openStoreCartFS(){
        storeFSBackdrop.style.display='none';
        storeFS.style.display='none';
        renderCart();
        updateCurrencyUI();
        storeCartBackdrop.style.display='block';
        storeCartFS.style.display='flex';
        resetScreenScroll(storeCartFS);
      }
      function closeStoreCartFS(){
        storeCartBackdrop.style.display='none';
        storeCartFS.style.display='none';
      }

      function openCheckoutFS(){
        updateOrderAndPayButton();
        checkoutFSBackdrop.style.display='block';
        checkoutFS.style.display='flex';
        resetScreenScroll(checkoutFS);
      }
      function closeCheckoutFS(){
        checkoutFSBackdrop.style.display='none';
        checkoutFS.style.display='none';
      }

      // Backend API helper functions
      const BACKEND_URL = 'https://thememorycalendar.onrender.com';
      const SUPPORT_EMAIL = 'thememorycalendar@gmail.com';
      const STATUS_POLL_INTERVAL = 3000; // Poll every 3 seconds
      const STATUS_POLL_TIMEOUT = 300000; // 5 minutes max

      async function startCheckout({ amountCents, currency, items, customer, address }) {
        try {
          const response = await fetch(`${BACKEND_URL}/api/checkout/create-session`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
              amount: amountCents, 
              currency: currency, 
              items: items, 
              customer: customer,
              address: address,
              customer_email: customer.email
            })
          });
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const data = await response.json();
          const sess = data.session_id || data.id;
          if (data.url && sess) {
            // Store session_id for later polling
            localStorage.setItem('stripe_session_id', sess);
            window.location.href = data.url;
          } else {
            throw new Error('No session URL or session identifier returned from backend');
          }
        } catch (error) {
          console.error('Checkout error:', error);
          throw error;
        }
      }

      async function checkPaymentStatus(sessionId) {
        try {
          const response = await fetch(`${BACKEND_URL}/api/checkout/status?session_id=${encodeURIComponent(sessionId)}`, {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' }
          });
          
          if (!response.ok) {
            if (response.status === 404) {
              return { paid: false, notFound: true };
            }
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const data = await response.json();
          return data;
        } catch (error) {
          console.error('Status check error:', error);
          throw error;
        }
      }

      async function uploadDeferredImages(sessionId, items) {
        try {
          console.info('[Upload Deferred Images] Uploading', items.length, 'items one-by-one');
          
          const uploadResults = [];
          
          // Upload each poster item individually to avoid payload size limits
          for (let i = 0; i < items.length; i++) {
            const item = items[i];
            console.info(`[Upload Deferred Images] Uploading item ${i + 1}/${items.length}`);
            
            // Transform single item to match backend schema
            const transformedItem = {
              ...item,
              snapshotDataUrl: item.snapshotDataUrl || item.snapshot || item.img || '',
              type: 'poster'
            };
            
            // Retry logic: up to 3 attempts per item
            let lastError = null;
            let uploadSuccess = false;
            
            for (let attempt = 1; attempt <= 3; attempt++) {
              try {
                if (attempt > 1) {
                  // Short delay before retry (linear backoff: 1000ms, 1500ms)
                  const delay = 500 * attempt;
                  console.info(`[Upload Deferred Images] Retry attempt ${attempt}/3 after ${delay}ms delay`);
                  await new Promise(resolve => setTimeout(resolve, delay));
                }
                
                const response = await fetch(`${BACKEND_URL}/api/checkout/upload-images`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ 
                    session_id: sessionId,
                    items: [transformedItem]
                  })
                });
                
                if (!response.ok) {
                  throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                console.info(`[Upload Deferred Images] Item ${i + 1}/${items.length} uploaded successfully`);
                uploadResults.push(result);
                uploadSuccess = true;
                break; // Success, exit retry loop
                
              } catch (error) {
                lastError = error;
                console.warn(`[Upload Deferred Images] Attempt ${attempt}/3 failed for item ${i + 1}:`, error.message);
              }
            }
            
            // If all retries failed, throw error
            if (!uploadSuccess) {
              console.error(`[Upload Deferred Images] Failed to upload item ${i + 1}/${items.length} after 3 attempts (session: ${sessionId})`);
              throw lastError || new Error(`Failed to upload item ${i + 1}/${items.length}`);
            }
          }
          
          console.info('[Upload Deferred Images] All items uploaded successfully');
          // Return structured result with individual upload responses
          // Note: Caller currently doesn't use return value, only checks success via try/catch
          return { success: true, results: uploadResults };
        } catch (error) {
          console.error('[Upload Deferred Images] Error:', error);
          throw error;
        }
      }

      function showThankYouPopup() {
        if (orderStatusMessage) {
          orderStatusMessage.textContent = transformForDisplay('thank you for your order! every order is greatly appreciated. please contact thememorycalendar@gmail.com for questions or support', 'sentence');
        }
        if (orderStatusBackBtn) {
          orderStatusBackBtn.style.display = 'block';
          orderStatusBackBtn.textContent = 'back to calendar';
        }
      }

      async function confirmOrder({ amountCents, currency, customer, address, items, sessionId }) {
        console.info('[Order Confirmation API] Sending confirm request:', {
          sessionId,
          amountCents,
          currency,
          itemCount: items.length
        });

        try {
          // First try with just session_id (new approach)
          console.info('[Order Confirmation API] Attempting session_id-only confirmation');
          let response = await fetch(`${BACKEND_URL}/api/checkout/confirm`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
              session_id: sessionId
            })
          });
          
          // If session_id-only fails with 404, fallback to full payload
          if (!response.ok && response.status === 404) {
            console.info('[Order Confirmation API] Session data not found, falling back to full payload');
            response = await fetch(`${BACKEND_URL}/api/checkout/confirm`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ 
                session_id: sessionId,
                amount: amountCents, 
                currency: currency, 
                customer: customer,
                address: address,
                items: items
              })
            });
          }
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const result = await response.json();
          console.info('[Order Confirmation API] Received response:', result);
          return result;
        } catch (error) {
          console.error('[Order Confirmation API] Error:', error);
          throw error;
        }
      }

      function updateOrderAndPayButton() {
        if (!orderAndPayBtn) return;
        const total = computeCartTotal();
        const symbolPrice = PRICES.delivery[currencyCode] || PRICES.delivery.eur;
        const prefix = symbolPrice.replace(/[\d.,].*$/, '');
        const currencyUpper = currencyCode.toUpperCase();
        orderAndPayBtn.textContent = `order and pay ‚Äì ${prefix}${total.toFixed(2)} ${currencyUpper}`;
      }

      async function handleOrderAndPay() {
        // Validate that both checkboxes are checked
        const tncChecked = tncBox && tncBox.getAttribute('aria-checked') === 'true';
        const nonRefundChecked = nonRefundBox && nonRefundBox.getAttribute('aria-checked') === 'true';
        
        if (!tncChecked || !nonRefundChecked) {
          alert('Please agree to the terms & conditions and acknowledge that prints are non-refundable.');
          return;
        }

        // Validate all 9 required customer information fields
        const firstName = checkoutFirstName ? checkoutFirstName.value.trim() : '';
        const lastName = checkoutLastName ? checkoutLastName.value.trim() : '';
        const email = checkoutEmail ? checkoutEmail.value.trim() : '';
        const phone = checkoutPhone ? checkoutPhone.value.trim() : '';
        const addressLine1 = checkoutStreet ? checkoutStreet.value.trim() : '';
        const city = checkoutCity ? checkoutCity.value.trim() : '';
        const state = checkoutState ? checkoutState.value.trim() : '';
        const postalCode = checkoutPostal ? checkoutPostal.value.trim() : '';
        const country = checkoutCountry ? checkoutCountry.value.trim() : '';

        // Check for missing required fields
        if (!firstName) {
          alert('Please enter your first name.');
          checkoutFirstName && checkoutFirstName.focus();
          return;
        }
        if (!lastName) {
          alert('Please enter your last name.');
          checkoutLastName && checkoutLastName.focus();
          return;
        }
        if (!email) {
          alert('Please enter your email address.');
          checkoutEmail && checkoutEmail.focus();
          return;
        }
        // Validate email format
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(email)) {
          alert('Please enter a valid email address.');
          checkoutEmail && checkoutEmail.focus();
          return;
        }
        if (!phone) {
          alert('Please enter your phone number.');
          checkoutPhone && checkoutPhone.focus();
          return;
        }
        if (!addressLine1) {
          alert('Please enter your street address.');
          checkoutStreet && checkoutStreet.focus();
          return;
        }
        if (!city) {
          alert('Please enter your city.');
          checkoutCity && checkoutCity.focus();
          return;
        }
        if (!state) {
          alert('Please enter your state/province.');
          checkoutState && checkoutState.focus();
          return;
        }
        if (!postalCode) {
          alert('Please enter your postal code.');
          checkoutPostal && checkoutPostal.focus();
          return;
        }
        if (!country) {
          alert('Please enter your country.');
          checkoutCountry && checkoutCountry.focus();
          return;
        }

        // Validate amounts
        const total = computeCartTotal();
        if (!Number.isFinite(total) || total <= 0) {
          alert('Invalid cart total. Please try again.');
          return;
        }

        const amountCents = Math.round(total * 100);
        if (!Number.isInteger(amountCents) || amountCents <= 0) {
          alert('Invalid amount. Please try again.');
          return;
        }

        // Disable button to prevent double clicks
        if (orderAndPayBtn) {
          orderAndPayBtn.disabled = true;
          orderAndPayBtn.textContent = 'processing...';
        }

        try {
          // Split items into polaroids (send now) and posters (defer)
          const polaroidItems = [];
          const posterItems = [];
          
          cartItems.forEach(item => {
            const isPolaroid = /polaroid/i.test(item.title || '');
            const itemData = {
              title: item.title || 'item',
              snapshotDataUrl: item.snapshotDataUrl || item.snapshot || item.img || '',
              price: item.price || '',
              summary: item.summary || '',
              hasSummary: item.hasSummary || false,
              soloPhoto: item.soloPhoto || false
            };
            
            if (isPolaroid) {
              polaroidItems.push(itemData);
            } else {
              posterItems.push(itemData);
            }
          });

          console.log('[Checkout] Polaroids to send now:', polaroidItems.length);
          console.log('[Checkout] Posters to defer:', posterItems.length);

          // Gather customer information (using validated variables)
          const customer = {
            first_name: firstName,
            last_name: lastName,
            email: email,
            phone: phone
          };

          // Gather address information (using validated variables)
          const address = {
            line1: addressLine1,
            line2: '',
            city: city,
            state: state,
            postal_code: postalCode,
            country: country
          };

          // Ensure currency is a valid 3-letter code (default to 'eur')
          const validCurrencies = ['eur', 'gbp', 'usd', 'cad', 'aud'];
          const safeCurrencyCode = (currencyCode && validCurrencies.includes(currencyCode)) ? currencyCode : 'eur';

          // Recompute total and amountCents immediately before checkout to ensure fresh values
          const finalTotal = computeCartTotal();
          const finalAmountCents = Math.round(finalTotal * 100);

          // Store pending order metadata (customer and address info)
          localStorage.setItem('pending-order', JSON.stringify({
            amountCents: finalAmountCents,
            currency: safeCurrencyCode,
            customer,
            address
          }));
          
          // Store poster items separately for dedicated post-payment upload
          if (posterItems && posterItems.length > 0) {
            localStorage.setItem('pending-order-posters', JSON.stringify(posterItems));
          }

          // Build items array for create-session: polaroids if available, else minimal poster summary
          let itemsToSendNow;
          if (polaroidItems.length > 0) {
            // Send polaroid items as-is
            itemsToSendNow = polaroidItems;
          } else if (posterItems.length > 0) {
            // Poster-only cart: send minimal summary item (no images, deferred upload remains unchanged)
            itemsToSendNow = [{
              type: 'poster',
              count: posterItems.length,
              title: 'month poster',
              summary: 'Poster order (deferred upload)'
            }];
          } else {
            // Empty cart - shouldn't reach here due to earlier validations
            itemsToSendNow = [];
          }

          // Call backend to create checkout session
          await startCheckout({
            amountCents: finalAmountCents,
            currency: safeCurrencyCode,
            items: itemsToSendNow,
            customer,
            address
          });
        } catch (error) {
          console.error('Order and pay error:', error);
          alert('Failed to start checkout. Please try again.');
          
          // Re-enable button
          if (orderAndPayBtn) {
            orderAndPayBtn.disabled = false;
            updateOrderAndPayButton();
          }
        }
      }

      /**
       * Confirm order after successful Stripe payment
       * This is called automatically when returning from Stripe with session_id in URL
       */
      // Check for success redirect on page load
      // Check for Stripe redirect and handle post-payment flow
      window.addEventListener('DOMContentLoaded', async () => {
        const urlParams = new URLSearchParams(window.location.search);
        const sessionId = urlParams.get('session_id');
        
        if (sessionId) {
          // Track polling timeout for cleanup
          let pollingTimeoutId = null;
          
          // Cleanup function to prevent memory leaks
          const cleanupPolling = () => {
            if (pollingTimeoutId) {
              clearTimeout(pollingTimeoutId);
              pollingTimeoutId = null;
              console.info('[Post-Payment] Polling cleanup completed');
            }
          };
          
          // Register cleanup on page unload
          window.addEventListener('beforeunload', cleanupPolling);
          
          // Show processing overlay
          if (orderStatusOverlay) {
            orderStatusOverlay.style.display = 'flex';
          }
          if (orderStatusMessage) {
            orderStatusMessage.textContent = 'processing your order‚Ä¶';
          }
          if (orderStatusBackBtn) {
            orderStatusBackBtn.style.display = 'none';
          }

          console.info('[Post-Payment] Starting post-payment flow for session:', sessionId);

          try {
            const pendingOrderJson = localStorage.getItem('pending-order');
            if (!pendingOrderJson) {
              console.error('[Post-Payment] No pending order data found');
              throw new Error('Order data not found. Please try checking out again.');
            }

            let orderData;
            try {
              orderData = JSON.parse(pendingOrderJson);
            } catch (parseError) {
              console.error('[Post-Payment] Failed to parse order data:', parseError);
              throw new Error('Order data is corrupted. Please try checking out again.');
            }

            console.info('[Post-Payment] Stored session_id for polling');
            
            // Start polling for payment status
            const startTime = Date.now();
            let statusCheckAttempts = 0;
            const maxAttempts = Math.ceil(STATUS_POLL_TIMEOUT / STATUS_POLL_INTERVAL);
            
            const pollStatus = async () => {
              statusCheckAttempts++;
              console.info(`[Post-Payment] Status check attempt ${statusCheckAttempts}/${maxAttempts}`);
              
              try {
                const statusResult = await checkPaymentStatus(sessionId);
                
                if (statusResult.paid) {
                  console.info('[Post-Payment] Payment confirmed! Starting deferred image upload.');
                  
                  // Cleanup polling
                  cleanupPolling();
                  
                  if (orderStatusMessage) {
                    orderStatusMessage.textContent = 'payment confirmed! uploading your order‚Ä¶';
                  }
                  
                  // Upload deferred poster items if any from dedicated storage
                  const pendingPostersJson = localStorage.getItem('pending-order-posters');
                  if (pendingPostersJson) {
                    try {
                      const posterItems = JSON.parse(pendingPostersJson);
                      if (Array.isArray(posterItems) && posterItems.length > 0) {
                        console.info('[Post-Payment] Uploading', posterItems.length, 'deferred poster items');
                        try {
                          await uploadDeferredImages(sessionId, posterItems);
                          console.info('[Post-Payment] Poster upload complete, clearing pending-order-posters');
                          localStorage.removeItem('pending-order-posters');
                        } catch (uploadError) {
                          console.error('[Post-Payment] Failed to upload poster images. User may need to contact support:', uploadError);
                          // Don't clear pending-order-posters on upload failure to preserve data for debugging
                        }
                      }
                    } catch (parseError) {
                      console.error('[Post-Payment] Failed to parse pending posters (clearing invalid data):', parseError);
                      // Clear invalid data from localStorage
                      localStorage.removeItem('pending-order-posters');
                    }
                  } else {
                    console.info('[Post-Payment] No deferred poster items to upload');
                  }
                  
                  // Clear cart and pending order
                  localStorage.removeItem('pending-order');
                  localStorage.removeItem('stripe_session_id');
                  localStorage.removeItem(CART_KEY);
                  cartItems = [];
                  
                  console.info('[Post-Payment] Order complete! Showing thank you message.');
                  
                  // Show thank-you popup
                  showThankYouPopup();
                  
                } else if (Date.now() - startTime > STATUS_POLL_TIMEOUT) {
                  // Timeout
                  cleanupPolling();
                  throw new Error('Payment status check timed out. Please contact support.');
                } else if (statusResult.notFound) {
                  // Session not found - might have expired
                  cleanupPolling();
                  throw new Error('Session not found. It may have expired.');
                } else {
                  // Not paid yet, continue polling
                  console.info('[Post-Payment] Payment not confirmed yet, will retry...');
                  pollingTimeoutId = setTimeout(pollStatus, STATUS_POLL_INTERVAL);
                }
              } catch (error) {
                console.error('[Post-Payment] Status check error:', error);
                
                // If it's a timeout or session not found, stop polling
                if (Date.now() - startTime > STATUS_POLL_TIMEOUT || error.message.includes('not found')) {
                  cleanupPolling();
                  throw error;
                }
                
                // Otherwise, retry
                pollingTimeoutId = setTimeout(pollStatus, STATUS_POLL_INTERVAL);
              }
            };
            
            // Start polling
            pollStatus();
            
          } catch (error) {
            console.error('[Post-Payment] Failed:', error);
            
            // Show error message
            if (orderStatusMessage) {
              orderStatusMessage.textContent = 'there was a problem processing your order. please contact ' + SUPPORT_EMAIL;
            }
            if (orderStatusBackBtn) {
              orderStatusBackBtn.style.display = 'block';
            }
          }
        }
      });

      window.addEventListener('resize', ()=> {
        positionStorePolaroidSummary();
      });

      function positionStorePolaroidSummary(){
        const storePolaroidCard=document.getElementById('storePolaroidCard');
        const storePolaroidImgWrap=document.getElementById('storePolaroidImgWrap');
        const storePolaroidSummary=document.getElementById('storePolaroidSummary');
        if(!storePolaroidCard || !storePolaroidImgWrap || !storePolaroidSummary) return;
        storePolaroidSummary.style.display=storePolaroidCard.classList.contains('has-summary')?'block':'none';
        if(storePolaroidSummary.style.display==='none') return;
        storePolaroidSummary.style.position='absolute';
        storePolaroidSummary.style.left='50%';
        storePolaroidSummary.style.transform='translateX(-50%)';
        const cardRect=storePolaroidCard.getBoundingClientRect();
        const imgRect=storePolaroidImgWrap.getBoundingClientRect();
        const summaryRect=storePolaroidSummary.getBoundingClientRect();
        const imageBottomWithinCard=imgRect.bottom - cardRect.top;
        const cardHeight=cardRect.height;
        const summaryHeight=summaryRect.height;
        const availableSpace=cardHeight - imageBottomWithinCard;
        const desiredTop=imageBottomWithinCard + (availableSpace - summaryHeight)/2;
        storePolaroidSummary.style.top=desiredTop + 'px';
      }

      function openSettingsFS(){
        lockBodyScroll();
        settingsFSBackdrop.style.display='block';
        settingsFS.style.display='flex';
        resetScreenScroll(settingsFS);
      }

      function closeSettingsFS(){
        settingsFSBackdrop.style.display='none';
        settingsFS.style.display='none';
        unlockBodyScroll();
      }

      updateCurrencyUI();

      const isIPhone=/iPhone/i.test(navigator.userAgent||'');
      if(isIPhone){
        restorePurchasesBtn.style.display='block';
        restorePurchasesBtn.addEventListener('click',()=>{
          try{
            if(window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.restorePurchases){
              window.webkit.messageHandlers.restorePurchases.postMessage({});
              showToast('restoring purchases');
            }else if(typeof window.restorePurchases==='function'){
              window.restorePurchases();
            }else{
              showToast('restore not available');
            }
          }catch(e){ showToast('restore error'); }
        });
      }

      renderCart();
      fontsChoices.forEach(btn=>btn.classList.toggle('selected', btn.dataset.font===fontKey));
      themeChoices.forEach(btn=>btn.classList.toggle('selected', btn.dataset.theme===themeKey));
      setupInfiniteCarousel();
      refreshDeleteMessage();
      refreshProductDescriptions();
      updateCartTotalButton();
      updateDeliveryFeeLabel();
      currencyChoices.forEach(c=>c.classList.toggle('selected', c.dataset.currency===currencyCode));

      // Show welcome popup on first run
      if(!tryGet(WELCOME_SEEN_KEY)){
        lockBodyScroll();
        welcomeModalBackdrop.style.display='block';
        welcomeModal.style.display='block';
        applyCapsToSentenceParagraphs();
      }

      // Replaced with actual compression - see compressToPreview() above
      async function compressDataUrl(dataUrl){ 
        return compressToPreview(dataUrl); 
      }

      /*
       * ============================================================================
       * API PAYLOAD DOCUMENTATION
       * ============================================================================
       * 
       * This section documents the structure of payloads sent to the backend API
       * endpoints for checkout and order confirmation.
       * 
       * ENDPOINT: POST /api/checkout/confirm
       * 
       * The confirm endpoint accepts the following payload structure:
       * 
       * {
       *   "session_id": "cs_test_abc123...",  // Required: Stripe checkout session ID
       *   "amount": 2500,                      // Optional (fallback): Amount in cents
       *   "currency": "usd",                   // Optional (fallback): Currency code (usd, eur, gbp)
       *   "customer": {                        // Optional (fallback): Customer details
       *     "first_name": "John",
       *     "last_name": "Doe",
       *     "email": "john.doe@example.com",   // Required field in customer object
       *     "phone": "+1234567890"
       *   },
       *   "address": {                         // Optional (fallback): Shipping address
       *     "line1": "123 Main Street",
       *     "line2": "Apt 4B",
       *     "city": "New York",
       *     "state": "NY",
       *     "postal_code": "10001",
       *     "country": "United States"
       *   },
       *   "items": [                           // Optional (fallback): Array of order items
       *     {
       *       "title": "daily polaroid",
       *       "snapshotDataUrl": "data:image/png;base64,iVBORw0KG...",  // Full quality PNG
       *       "price": "$2.50",
       *       "summary": "January 1st\nFamily gathering",
       *       "hasSummary": true,
       *       "soloPhoto": false
       *     }
       *   ]
       * }
       * 
       * IMPORTANT NOTES:
       * 
       * 1. Session-based confirmation (preferred):
       *    - The backend stores order data when creating a Stripe session
       *    - Confirm requests need only the session_id
       *    - Stored data automatically expires after 24 hours
       * 
       * 2. Fallback mode (legacy support):
       *    - If session data is not found, the full payload is used
       *    - This ensures backward compatibility with older implementations
       * 
       * 3. Image quality:
       *    - Images are generated using canvas.toDataURL('image/png')
       *    - PNG format is lossless, ensuring full quality preservation
       *    - No quality parameter = maximum quality (no compression)
       * 
       * 4. Data flow:
       *    - User fills checkout form with customer and address details
       *    - Data stored in localStorage as 'pending-order'
       *    - After Stripe redirect, data sent to /api/checkout/confirm
       *    - Backend sends confirmation email with attachments
       *    - Attachments batched if total size exceeds 18 MB
       * 
       * EXAMPLE USAGE IN CODE:
       * 
       * // Store order data before Stripe redirect
       * localStorage.setItem('pending-order', JSON.stringify({
       *   amountCents: 2500,
       *   currency: 'usd',
       *   customer: { first_name: 'John', last_name: 'Doe', email: 'john@example.com', phone: '+1234567890' },
       *   address: { line1: '123 Main St', line2: '', city: 'New York', state: 'NY', postal_code: '10001', country: 'US' },
       *   items: [{ title: 'daily polaroid', snapshotDataUrl: 'data:image/png;base64,...', ... }]
       * }));
       * 
       * // After Stripe redirect, retrieve and send to backend
       * const orderData = JSON.parse(localStorage.getItem('pending-order'));
       * await fetch('/api/checkout/confirm', {
       *   method: 'POST',
       *   headers: { 'Content-Type': 'application/json' },
       *   body: JSON.stringify({
       *     session_id: 'cs_test_abc123...',
       *     amount: orderData.amountCents,
       *     currency: orderData.currency,
       *     customer: orderData.customer,
       *     address: orderData.address,
       *     items: orderData.items
       *   })
       * });
       * 
       * ============================================================================
       */

    })();
  </script>
  <script>
    (function(){
      if (typeof screen !== 'undefined' && screen.orientation && screen.orientation.lock) {
        document.addEventListener('click', function lockOnce() {
          screen.orientation.lock('portrait-primary').then(function() {
            console.log('Orientation locked to portrait');
          }).catch(function(err) {
            console.warn('Could not lock orientation:', err);
          });
          document.removeEventListener('click', lockOnce);
        }, { once: true });
      }
    })();
  </script>
</body>
</html>